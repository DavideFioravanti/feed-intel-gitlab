From 596f79321f36a56814007fc5c964cd5e44beff43 Mon Sep 17 00:00:00 2001
From: CI Assistant <yossi.ilkanaev@intel.com>
Date: Tue, 28 Aug 2018 12:12:24 +0200
Subject: [PATCH] Merge pull request #151 in SW_UGW/linux from
 feature/DRVLIB_SW-891-ax3000-microcode-for-f24s-trunking to master

* commit '7be7d57ffcd0b726b7bbec77ae66f366e1063f48':
  format corrected
  bug fix in PCE rule read
  Axe model code update including Micro code,bug fixes and enchancement
---
 .../net/ethernet/lantiq/switch-api/gsw_flow_core.c | 280 ++++---
 .../net/ethernet/lantiq/switch-api/gsw_flow_core.h |   8 +-
 .../net/ethernet/lantiq/switch-api/gsw_flow_pce.c  | 900 +++++++++++----------
 drivers/net/ethernet/lantiq/switch-api/gsw_init.c  |  87 +-
 drivers/net/ethernet/lantiq/switch-api/gsw_init.h  |   1 +
 .../net/ethernet/lantiq/switch-api/gsw_tbl_rw.c    |   3 +-
 6 files changed, 699 insertions(+), 580 deletions(-)

diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.c b/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.c
index e5908fe75583..4e36d1fd259e 100644
--- a/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.c
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.c
@@ -353,6 +353,7 @@ static void reset_multicast_sw_table(void *cdev)
 		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
 		return;
 	}
+
 	if (IS_VRSN_31(gswdev->gipver)) {
 		gsw_init_hash_table(cdev);
 	}
@@ -382,7 +383,7 @@ static int gsw2x_msw_table_wr(void *cdev, GSW_multicastTable_t *parm)
 	pce_dasa_msb_t	mtbl;
 	ltq_pce_table_t *hpctbl = NULL;
 	gsw_igmp_t *hitbl = NULL;
-	
+
 	if (gswdev == NULL) {
 		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
 		return GSW_statusErr;
@@ -951,7 +952,7 @@ static int gsw3x_msw_table_wr(void *cdev, GSW_multicastTable_t *parm)
 	pce_dasa_msb_t	mtbl;
 	ltq_pce_table_t *hpctbl = NULL;
 	gsw_igmp_t *hitbl = NULL;
-	
+
 	if (gswdev == NULL) {
 		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
 		return GSW_statusErr;
@@ -1678,7 +1679,7 @@ static int gsw2x_msw_table_rm(void *cdev, GSW_multicastTable_t *parm)
 	pce_dasa_lsb_t ltbl;
 	pce_dasa_msb_t mtbl;
 	int dlix = 0, dmix = 0, slix = 0, smix = 0;
-	
+
 	if (gswdev == NULL) {
 		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
 		return GSW_statusErr;
@@ -2614,6 +2615,7 @@ static void get_gsw_hw_cap(void *cdev)
 		printk("\n");
 		printk("Number of logical port           =  %d\n", gswdev->pnum);
 		printk("Number of ports including V port =  %d\n", gswdev->tpnum);
+
 		if (gswdev->gipver == LTQ_GSWIP_3_1) {
 			printk("Number of CTP Port               =  %d\n", gswdev->num_of_ctp);
 			printk("Number of Bridge                 =  %d\n", gswdev->num_of_bridge);
@@ -2621,6 +2623,7 @@ static void get_gsw_hw_cap(void *cdev)
 			printk("Number of P-Mapper               =  %d\n", gswdev->num_of_pmapper);
 
 		}
+
 		printk("Number of queues                 =  %d\n", gswdev->num_of_queues);
 		printk("Number of meter instance         =  %d\n", gswdev->num_of_meters);
 		printk("Number of shapers                =  %d\n", gswdev->num_of_shapers);
@@ -2645,6 +2648,7 @@ static void get_gsw_hw_cap(void *cdev)
 			printk("Extend VLAN Table Size table     =  %d\n", gswdev->num_of_extendvlan);
 			printk("VlanFilter table Size            =  %d\n\n", gswdev->num_of_vlanfilter);
 		}
+
 		printk("\n");
 	}
 
@@ -3124,6 +3128,7 @@ static GSW_return_t switch_core_init(void *cdev)
 			mac_init_fn_ptrs(mac_ops);
 			mac_ops->init(mac_ops);
 		}
+
 		struct adap_ops *ops = gsw_get_adap_ops(0);
 
 		if (ops == NULL) {
@@ -3168,29 +3173,31 @@ void *ethsw_api_core_init(ethsw_core_init_t *ethcinit)
 	ethsw_api_dev_t *PrvData;
 	struct core_ops *ops;
 	void *cdev;
-	u32 ret;
-	printk("\n########## Switch Core INIT for device = %d ##########\n",ethcinit->sdev);
+	u32 ret = 0;
+	printk("\n########## Switch Core INIT for device = %d ##########\n", ethcinit->sdev);
 
 #ifdef __KERNEL__
+
 	/* KERNEL_MODE */
 	/** Get Platform Driver Data */
-	if((ethcinit->sdev == LTQ_FLOW_DEV_INT) || (ethcinit->sdev == LTQ_FLOW_DEV_INT_R)) {
-	ops = platform_get_drvdata(ethcinit->pdev);
+	if ((ethcinit->sdev == LTQ_FLOW_DEV_INT) || (ethcinit->sdev == LTQ_FLOW_DEV_INT_R)) {
+		ops = platform_get_drvdata(ethcinit->pdev);
 
-	/** Get Switch Core Private Data */
-	PrvData = container_of(ops, ethsw_api_dev_t, ops);
+		/** Get Switch Core Private Data */
+		PrvData = container_of(ops, ethsw_api_dev_t, ops);
 
-	if (PrvData == NULL) {
-		pr_err("%s:%s:%d (Plateform driver data not allocated)\n",
-		       __FILE__, __func__, __LINE__);
-		return PrvData;
-	}
+		if (PrvData == NULL) {
+			pr_err("%s:%s:%d (Plateform driver data not allocated)\n",
+			       __FILE__, __func__, __LINE__);
+			return PrvData;
+		}
 
-	/** Clear Switch Core Private Data */
+		/** Clear Switch Core Private Data */
 	} else {
 		/*External switch*/
 		PrvData = ethcinit->pdev;
 	}
+
 	/** Set Core OPS struct Adress to cdev*/
 	cdev = &PrvData->ops;
 
@@ -3248,7 +3255,8 @@ void *ethsw_api_core_init(ethsw_core_init_t *ethcinit)
 	}
 
 #if defined(CONFIG_LTQ_MULTICAST) && CONFIG_LTQ_MULTICAST
-	if((ethcinit->sdev == LTQ_FLOW_DEV_INT) || (ethcinit->sdev == LTQ_FLOW_DEV_INT_R)) {
+
+	if ((ethcinit->sdev == LTQ_FLOW_DEV_INT) || (ethcinit->sdev == LTQ_FLOW_DEV_INT_R)) {
 		/*Reset Multicast software table*/
 		reset_multicast_sw_table(cdev);
 	}
@@ -3263,17 +3271,19 @@ void *ethsw_api_core_init(ethsw_core_init_t *ethcinit)
 	gsw_w32(cdev, PCE_GCTRL_0_MC_VALID_OFFSET,
 		PCE_GCTRL_0_MC_VALID_SHIFT, PCE_GCTRL_0_MC_VALID_SIZE, 0x1);
 #else
-	if((ethcinit->sdev == LTQ_FLOW_DEV_INT) || (ethcinit->sdev == LTQ_FLOW_DEV_INT_R)) {
+
+	if ((ethcinit->sdev == LTQ_FLOW_DEV_INT) || (ethcinit->sdev == LTQ_FLOW_DEV_INT_R)) {
 		gsw_pmicro_code_init(cdev);
 		printk("Switch API: PCE MicroCode loaded !!\n");
 	}
+
 #endif
 
-	if((ethcinit->sdev == LTQ_FLOW_DEV_INT) || (ethcinit->sdev == LTQ_FLOW_DEV_INT_R)) {
-	if (IS_VRSN_31(PrvData->gipver))
-		switch_core_init(cdev);
-	else
-		legacy_switch_core_init(cdev);
+	if ((ethcinit->sdev == LTQ_FLOW_DEV_INT) || (ethcinit->sdev == LTQ_FLOW_DEV_INT_R)) {
+		if (IS_VRSN_31(PrvData->gipver))
+			switch_core_init(cdev);
+		else
+			legacy_switch_core_init(cdev);
 	}
 
 #ifdef CONFIG_X86_INTEL_CE2700
@@ -7033,14 +7043,28 @@ GSW_return_t GSW_QoS_MeterCfgSet(void *cdev,
 	spin_lock_bh(&gswdev->lock_misc);
 #endif
 
+	/*Change summary of GSW_QoS_MeterCfgSet for GSWIP 3.1
+		1. Meter Color Blind is newly added
+		2. IBS is byte based
+	*/
+
 	mid = parm->nMeterId;
 
 	if (IS_VRSN_30_31(gswdev->gipver)) {
-		if (mid > gswdev->num_of_meters) {
+		if (mid >= gswdev->num_of_meters) {
 			ret = GSW_statusErr;
 			goto UNLOCK_AND_RETURN;
 		}
 
+
+		if (IS_VRSN_31(gswdev->gipver)) {
+			/*Check whether it is InUSE,if not InUse,return ERROR*/
+			if (!(gswdev->meter_idx[mid].IndexInUse)) {
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+		}
+
 		gsw_w32(cdev, GSW_INST_SEL_INST_OFFSET,
 			GSW_INST_SEL_INST_SHIFT,
 			GSW_INST_SEL_INST_SIZE, mid);
@@ -8618,6 +8642,7 @@ GSW_return_t GSW_QoS_QueuePortSet(void *cdev,
 	if (IS_VRSN_31(gswdev->gipver)) {
 		GSW_Freeze();
 	}
+
 #ifdef __KERNEL__
 	spin_lock_bh(&gswdev->lock_pce);
 #endif
@@ -8689,6 +8714,7 @@ GSW_return_t GSW_QoS_QueuePortSet(void *cdev,
 	bmtable.tableID = BUF_MGR_Q_MAP_TABLE;
 	bmtable.numValues = 1;
 	ret = gsw_bm_table_write(cdev, &bmtable);
+
 	if (IS_VRSN_31(gswdev->gipver)) {
 		GSW_UnFreeze();
 	}
@@ -11666,10 +11692,10 @@ GSW_return_t GSW_CapGet(void *cdev, GSW_cap_t *parm)
 
 	switch (parm->nCapType) {
 	case GSW_CAP_TYPE_PORT:
+
 		/*Temp work around for the below external switch model*/
-		if(gswdev->gsw_dev == LTQ_FLOW_DEV_EXT_AX3000_F24S)
-		{
-			get_gsw_hw_cap (cdev);
+		if (gswdev->gsw_dev == LTQ_FLOW_DEV_EXT_AX3000_F24S) {
+			get_gsw_hw_cap(cdev);
 		}
 
 		gsw_r32(cdev, ETHSW_CAP_1_PPORTS_OFFSET,
@@ -12095,8 +12121,8 @@ GSW_return_t GSW_CfgSet(void *cdev, GSW_cfg_t *parm)
 GSW_return_t GSW_HW_Init(void *cdev, GSW_HW_Init_t *parm)
 {
 	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
-	u32 j;
-	u32 ret;
+	u32 j = 0;
+	u32 ret = 0;
 
 	if (gswdev == NULL) {
 		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
@@ -12107,94 +12133,109 @@ GSW_return_t GSW_HW_Init(void *cdev, GSW_HW_Init_t *parm)
 	spin_lock_bh(&gswdev->lock_pce);
 #endif
 
-	/* Reset the Switch via Switch IP register*/
-	j = 1;
-	gsw_w32(cdev, ETHSW_SWRES_R0_OFFSET,
-		ETHSW_SWRES_R0_SHIFT, ETHSW_SWRES_R0_SIZE, j);
+	if (gswdev->gsw_dev == LTQ_FLOW_DEV_EXT_AX3000_F24S) {
+		/* Reset the Switch via Switch IP register*/
+		get_gsw_hw_cap(cdev);
+		/* Software Table Init */
+		ltq_ethsw_port_cfg_init(cdev);
+		//rst_multi_sw_table(cdev);
+		/* HW Init */
+		gsw_pmicro_code_init_f24s(cdev);
+		printk("Switch API: PCE MicroCode loaded for LTQ_FLOW_DEV_EXT_AX3000_F24S\n");
+		/*hardcoded setting for LTQ_FLOW_DEV_EXT_AX3000_F24S*/
+		ret = GSW_statusOk;
 
-	do {
+	} else {
+
+		/* Reset the Switch via Switch IP register*/
+		j = 1;
+		gsw_w32(cdev, ETHSW_SWRES_R0_OFFSET,
+			ETHSW_SWRES_R0_SHIFT, ETHSW_SWRES_R0_SIZE, j);
+
+		do {
 //		udelay(100);
-		gsw_r32(cdev, ETHSW_SWRES_R0_OFFSET,
-			ETHSW_SWRES_R0_SHIFT, ETHSW_SWRES_R0_SIZE, &j);
-	} while (j);
+			gsw_r32(cdev, ETHSW_SWRES_R0_OFFSET,
+				ETHSW_SWRES_R0_SHIFT, ETHSW_SWRES_R0_SIZE, &j);
+		} while (j);
 
 #if defined(CONFIG_USE_EMULATOR) && CONFIG_USE_EMULATOR
 
-	if (gswdev->gipver == LTQ_GSWIP_3_0) {
-		/* Set Auto-Polling of connected PHYs - For all ports */
-		gsw_w32(cdev, (GSWT_MDCCFG_0_PEN_1_OFFSET
-			       + GSW30_TOP_OFFSET),
-			GSWT_MDCCFG_0_PEN_1_SHIFT, 6, 0x0);
-	} else {
-		/* Set Auto-Polling of connected PHYs - For all ports */
-		gsw_w32(cdev, (MDC_CFG_0_PEN_0_OFFSET
-			       + GSW_TREG_OFFSET),
-			MDC_CFG_0_PEN_0_SHIFT, 6, 0x0);
-	}
+		if (gswdev->gipver == LTQ_GSWIP_3_0) {
+			/* Set Auto-Polling of connected PHYs - For all ports */
+			gsw_w32(cdev, (GSWT_MDCCFG_0_PEN_1_OFFSET
+				       + GSW30_TOP_OFFSET),
+				GSWT_MDCCFG_0_PEN_1_SHIFT, 6, 0x0);
+		} else {
+			/* Set Auto-Polling of connected PHYs - For all ports */
+			gsw_w32(cdev, (MDC_CFG_0_PEN_0_OFFSET
+				       + GSW_TREG_OFFSET),
+				MDC_CFG_0_PEN_0_SHIFT, 6, 0x0);
+		}
 
 #else
 
-	if (gswdev->gipver == LTQ_GSWIP_3_0) {
-		if (gswdev->sdev == LTQ_FLOW_DEV_INT_R) {
+		if (gswdev->gipver == LTQ_GSWIP_3_0) {
+			if (gswdev->sdev == LTQ_FLOW_DEV_INT_R) {
 #ifdef __KERNEL__
-			gsw_r_init();
+				gsw_r_init();
 #endif
-			gsw_w32(cdev, (GSWT_MDCCFG_0_PEN_1_OFFSET + GSW30_TOP_OFFSET),
-				GSWT_MDCCFG_0_PEN_1_SHIFT, 6, 0x1);
-		} else {
-			gsw_w32(cdev, (GSWT_MDCCFG_0_PEN_1_OFFSET + GSW30_TOP_OFFSET),
-				GSWT_MDCCFG_0_PEN_1_SHIFT, 6, 0x1e);
+				gsw_w32(cdev, (GSWT_MDCCFG_0_PEN_1_OFFSET + GSW30_TOP_OFFSET),
+					GSWT_MDCCFG_0_PEN_1_SHIFT, 6, 0x1);
+			} else {
+				gsw_w32(cdev, (GSWT_MDCCFG_0_PEN_1_OFFSET + GSW30_TOP_OFFSET),
+					GSWT_MDCCFG_0_PEN_1_SHIFT, 6, 0x1e);
+			}
 		}
-	}
 
 #endif  /* CONFIG_USE_EMULATOR */
-	/*	platform_device_init(cdev); */
-	gswdev->hwinit = 1;
-	/*	get_gsw_hw_cap (cdev); */
-	/* Software Table Init */
+		/*	platform_device_init(cdev); */
+		gswdev->hwinit = 1;
+		/*	get_gsw_hw_cap (cdev); */
+		/* Software Table Init */
 #if defined(CONFIG_LTQ_VLAN) && CONFIG_LTQ_VLAN
-	reset_vlan_sw_table(cdev);
+		reset_vlan_sw_table(cdev);
 #endif /*CONFIG_LTQ_VLAN */
-	ltq_ethsw_port_cfg_init(cdev);
+		ltq_ethsw_port_cfg_init(cdev);
 #if defined(CONFIG_LTQ_MULTICAST) && CONFIG_LTQ_MULTICAST
-	reset_multicast_sw_table(cdev);
+		reset_multicast_sw_table(cdev);
 #endif /*CONFIG_LTQ_MULTICAST*/
-	pce_table_init(&gswdev->phandler);
-	/* HW Init */
-	gsw_pmicro_code_init(cdev);
+		pce_table_init(&gswdev->phandler);
+		/* HW Init */
+		gsw_pmicro_code_init(cdev);
 
-	if (gswdev->gipver == LTQ_GSWIP_3_0) {
-		if (gswdev->sdev == LTQ_FLOW_DEV_INT_R) {
-			/*suresh*/
-//			rt_table_init();
-			gsw_w32(cdev, PCE_TFCR_NUM_NUM_OFFSET, PCE_TFCR_NUM_NUM_SHIFT,
-				PCE_TFCR_NUM_NUM_SIZE, 0x80);
-		}
+		if (gswdev->gipver == LTQ_GSWIP_3_0) {
+			if (gswdev->sdev == LTQ_FLOW_DEV_INT_R) {
+				/*suresh*/
+				//			rt_table_init();
+				gsw_w32(cdev, PCE_TFCR_NUM_NUM_OFFSET, PCE_TFCR_NUM_NUM_SHIFT,
+					PCE_TFCR_NUM_NUM_SIZE, 0x80);
+			}
 
-		/* EEE auto negotiation overides:*/
-		/*  clock disable (ANEG_EEE_0.CLK_STOP_CAPABLE)  */
-		for (j = 0; j < gswdev->pnum - 1; j++) {
-			gsw_w32(cdev,
-				((GSWT_ANEG_EEE_1_CLK_STOP_CAPABLE_OFFSET
-				  + (4 * j)) + GSW30_TOP_OFFSET),
-				GSWT_ANEG_EEE_1_CLK_STOP_CAPABLE_SHIFT,
-				GSWT_ANEG_EEE_1_CLK_STOP_CAPABLE_SIZE, 0x3);
-		}
-	} else {
-		/* Configure the MDIO Clock 97.6 Khz */
-		gsw_w32(cdev, (MDC_CFG_1_FREQ_OFFSET + GSW_TREG_OFFSET),
-			MDC_CFG_1_FREQ_SHIFT,
-			MDC_CFG_1_FREQ_SIZE, 0xFF);
+			/* EEE auto negotiation overides:*/
+			/*  clock disable (ANEG_EEE_0.CLK_STOP_CAPABLE)  */
+			for (j = 0; j < gswdev->pnum - 1; j++) {
+				gsw_w32(cdev,
+					((GSWT_ANEG_EEE_1_CLK_STOP_CAPABLE_OFFSET
+					  + (4 * j)) + GSW30_TOP_OFFSET),
+					GSWT_ANEG_EEE_1_CLK_STOP_CAPABLE_SHIFT,
+					GSWT_ANEG_EEE_1_CLK_STOP_CAPABLE_SIZE, 0x3);
+			}
+		} else {
+			/* Configure the MDIO Clock 97.6 Khz */
+			gsw_w32(cdev, (MDC_CFG_1_FREQ_OFFSET + GSW_TREG_OFFSET),
+				MDC_CFG_1_FREQ_SHIFT,
+				MDC_CFG_1_FREQ_SIZE, 0xFF);
 
-		for (j = 0; j < gswdev->pnum - 1; j++) {
-			gsw_w32(cdev, ((ANEG_EEE_0_CLK_STOP_CAPABLE_OFFSET + j)
-				       + GSW_TREG_OFFSET),
-				ANEG_EEE_0_CLK_STOP_CAPABLE_SHIFT,
-				ANEG_EEE_0_CLK_STOP_CAPABLE_SIZE, 0x3);
+			for (j = 0; j < gswdev->pnum - 1; j++) {
+				gsw_w32(cdev, ((ANEG_EEE_0_CLK_STOP_CAPABLE_OFFSET + j)
+					       + GSW_TREG_OFFSET),
+					ANEG_EEE_0_CLK_STOP_CAPABLE_SHIFT,
+					ANEG_EEE_0_CLK_STOP_CAPABLE_SIZE, 0x3);
+			}
 		}
-	}
 
-	ret = GSW_statusOk;
+		ret = GSW_statusOk;
+	}
 
 #ifdef __KERNEL__
 	spin_unlock_bh(&gswdev->lock_pce);
@@ -17135,7 +17176,7 @@ GSW_return_t GSW_CPU_PortCfgGet(void *cdev, GSW_CPU_PortCfg_t *parm)
 					goto UNLOCK_AND_RETURN;
 				}
 
-				parm->bFcsTxOps = ops->get_fcsgen(ops);
+				parm->bFcsGenerate = ops->get_fcsgen(ops);
 #endif
 			}
 		}
@@ -17183,7 +17224,6 @@ GSW_return_t GSW_CPU_PortCfgSet(void *cdev, GSW_CPU_PortCfg_t *parm)
 	u32 RST, AS, AST, RXSH;
 	u32 ret;
 
-
 	if (gswdev == NULL) {
 		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
 		return GSW_statusErr;
@@ -17268,8 +17308,8 @@ GSW_return_t GSW_CPU_PortCfgSet(void *cdev, GSW_CPU_PortCfg_t *parm)
 					ret = GSW_statusErr;
 					goto UNLOCK_AND_RETURN;
 				}
-				
-				ops->set_fcsgen(ops, parm->bFcsTxOps);
+
+				ops->set_fcsgen(ops, 1);
 #endif
 			}
 		}
@@ -25592,48 +25632,32 @@ GSW_return_t GSW_QOS_MeterAlloc(void *cdev, GSW_QoS_meterCfg_t *param)
 	spin_lock_bh(&gswdev->lock_alloc);
 #endif
 
-	/*If Meter ID is invalid ,find a new meter index
-	  and allocate*/
-
-	if (param->nMeterId == METER_ENTRY_INVALID) {
-		for (idx = 0; idx < gswdev->num_of_meters && !freeidxfound; idx++) {
-			if (!(gswdev->meter_idx[idx].IndexInUse)) {
-				gswdev->meter_idx[idx].IndexInUse = 1;
-				param->nMeterId = idx;
-				freeidxfound = 1;
-			}
-		}
-
-		/*No free Slot return Error*/
-		if (!freeidxfound) {
-			ret = GSW_statusErr;
-			goto UNLOCK_AND_RETURN;
+	/*Find free meter indexand allocate*/
+	for (idx = 0; idx < gswdev->num_of_meters && !freeidxfound; idx++) {
+		if (!(gswdev->meter_idx[idx].IndexInUse)) {
+			gswdev->meter_idx[idx].IndexInUse = 1;
+			param->nMeterId = idx;
+			freeidxfound = 1;
 		}
 	}
 
-	if (param->nMeterId > gswdev->num_of_meters) {
+	/*No free Slot return Error*/
+	if (!freeidxfound) {
 		ret = GSW_statusErr;
 		goto UNLOCK_AND_RETURN;
 	}
 
-	if (param->nMeterId > (METER_TABLE_SIZE - 1)) {
+	if (param->nMeterId >= gswdev->num_of_meters) {
 		ret = GSW_statusErr;
 		goto UNLOCK_AND_RETURN;
 	}
 
-	/*If Meter ID is valid,Check whether it is InUSE
-	  if not InUse,return ERROR*/
+	/*Check whether it is InUSE,if not InUse,return ERROR*/
 	if (!(gswdev->meter_idx[param->nMeterId].IndexInUse)) {
 		ret = GSW_statusErr;
 		goto UNLOCK_AND_RETURN;
 	}
 
-	/*Change summary of GSW_QoS_MeterCfgSet for GSWIP 3.1
-		1. Meter Color Blind is newly added
-		2. IBS is byte based
-	*/
-	ret = GSW_QoS_MeterCfgSet(cdev, param);
-
 UNLOCK_AND_RETURN:
 
 #ifdef __KERNEL__
@@ -25656,7 +25680,7 @@ GSW_return_t GSW_QOS_MeterFree(void *cdev, GSW_QoS_meterCfg_t *param)
 	spin_lock_bh(&gswdev->lock_free);
 #endif
 
-	if (param->nMeterId > gswdev->num_of_meters) {
+	if (param->nMeterId >= gswdev->num_of_meters) {
 		ret = GSW_statusErr;
 		goto UNLOCK_AND_RETURN;
 	}
@@ -25666,11 +25690,6 @@ GSW_return_t GSW_QOS_MeterFree(void *cdev, GSW_QoS_meterCfg_t *param)
 		goto UNLOCK_AND_RETURN;
 	}
 
-	if (param->nMeterId > (METER_TABLE_SIZE - 1)) {
-		ret = GSW_statusErr;
-		goto UNLOCK_AND_RETURN;
-	}
-
 	/*If Meter ID is valid,Check whether it is InUSE
 	  if not InUse,return ERROR*/
 	if (!gswdev->meter_idx[param->nMeterId].IndexInUse) {
@@ -26394,6 +26413,7 @@ GSW_return_t GSW_Enable(void *cdev)
 
 	if (IS_VRSN_31(gswdev->gipver)) {
 		struct adap_ops *ops = get_adap_ops(gswdev);
+
 		if (ops == NULL) {
 			pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
 			return GSW_statusErr;
diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.h b/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.h
index 8eec8a1f4d58..e10ba896f0f4 100644
--- a/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.h
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.h
@@ -403,7 +403,9 @@ enum {
 	GOUT_APP1,
 	GOUT_IGMP0,
 	GOUT_IGMP1,
-	GOUT_IPOFF,	/*39*/
+//	GOUT_IPOFF,	/*39*/
+	GOUT_STAG0 = 61,
+	GOUT_STAG1 = 62,
 	GOUT_NONE	=	63,
 };
 
@@ -423,6 +425,7 @@ enum {
 	GFLAG_NN2,
 	GFLAG_END,
 	GFLAG_NO,	/*13*/
+	GFLAG_SVLAN,  /*14 */
 };
 
 typedef struct {
@@ -516,7 +519,7 @@ typedef enum {
 typedef enum {
 	LTQ_FLOW_DEV_INT	= 0,
 	LTQ_FLOW_DEV_INT_R	= 1,
-	LTQ_FLOW_DEV_EXT_AX3000_F24S = 2,	
+	LTQ_FLOW_DEV_EXT_AX3000_F24S = 2,
 	LTQ_FLOW_DEV_MAX
 } gsw_devtype_t;
 
@@ -988,6 +991,7 @@ typedef struct {
 
 
 
+int gsw_pmicro_code_init_f24s(void *cdev);
 
 u8 find_active_vlan_index(void *cdev, u16 vid);
 int find_msb_tbl_entry(pcetbl_prog_t *ptbl,
diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_flow_pce.c b/drivers/net/ethernet/lantiq/switch-api/gsw_flow_pce.c
index 65b30c4e19dc..ed165761ae1a 100644
--- a/drivers/net/ethernet/lantiq/switch-api/gsw_flow_pce.c
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_flow_pce.c
@@ -539,74 +539,79 @@ const PCE_MICROCODE pce_mc_max_ifx_tag_m_30 = {/* V30_13 */
 #define PCE_MC_M(val, msk, ns, out, len, type, flags, ipv4_len) \
 	{ val, msk, (ns<<10 | out<<4 | len>>1),\
 		(len&1)<<15 | type<<13 | flags<<9 | ipv4_len<<8 }
+
+
 const PCE_MICROCODE pce_mc_max_ifx_tag_m = {
 	/*-----------------------------------------------------------------*/
 	/**   value    mask   ns  out_fields   L  type   flags   ipv4_len **/
 	/*-----------------------------------------------------------------*/
-	PCE_MC_M(0x88c3, 0xFFFF, 1, GOUT_ITAG0, 4, INSTR, GFLAG_ITAG, 0),
-	PCE_MC_M(0x8100, 0xFFFF, 2, GOUT_VTAG0, 2, INSTR, GFLAG_VLAN, 0),
-	PCE_MC_M(0x88A8, 0xFFFF, 1, GOUT_VTAG0, 2, INSTR, GFLAG_VLAN, 0),
-	PCE_MC_M(0x8100, 0xFFFF, 1, GOUT_VTAG0, 2, INSTR, GFLAG_VLAN, 0),
-	PCE_MC_M(0x8864, 0xFFFF, 17, GOUT_ETHTYP, 1, INSTR, GFLAG_NO, 0),
-	PCE_MC_M(0x0800, 0xFFFF, 21, GOUT_ETHTYP,	1, INSTR, GFLAG_NO, 0),
-	PCE_MC_M(0x86DD, 0xFFFF, 22, GOUT_ETHTYP,	1, INSTR, GFLAG_NO, 0),
-	PCE_MC_M(0x8863, 0xFFFF, 16, GOUT_ETHTYP, 1, INSTR, GFLAG_NO, 0),
-	PCE_MC_M(0x0000, 0xF800, 10, GOUT_NONE, 0, INSTR, GFLAG_NO, 0),
-	PCE_MC_M(0x0000, 0x0000, 40, GOUT_ETHTYP,	1, INSTR, GFLAG_NO, 0),
-	PCE_MC_M(0x0600, 0x0600, 40, GOUT_ETHTYP,	1, INSTR, GFLAG_NO, 0),
-	PCE_MC_M(0x0000, 0x0000, 12, GOUT_NONE, 1, INSTR, GFLAG_NO, 0),
-	PCE_MC_M(0xAAAA, 0xFFFF, 14, GOUT_NONE, 1, INSTR, GFLAG_NO, 0),
-	PCE_MC_M(0x0000, 0x0000, 41, GOUT_NONE,	0, INSTR, GFLAG_NO, 0),
-	PCE_MC_M(0x0300, 0xFF00, 41, GOUT_NONE,	0, INSTR, GFLAG_SNAP, 0),
-	PCE_MC_M(0x0000, 0x0000, 41, GOUT_NONE,	0, INSTR, GFLAG_NO, 0),
-	PCE_MC_M(0x0000, 0x0000, 41, GOUT_DIP7,	3, INSTR, GFLAG_NO, 0),
-	PCE_MC_M(0x0000, 0x0000, 18, GOUT_DIP7, 3, INSTR, GFLAG_PPPOE, 0),
-	PCE_MC_M(0x0021, 0xFFFF, 21, GOUT_NONE,	1, INSTR, GFLAG_NO, 0),
-	PCE_MC_M(0x0057, 0xFFFF, 22, GOUT_NONE,	1, INSTR, GFLAG_NO, 0),
-	PCE_MC_M(0x0000, 0x0000, 40, GOUT_NONE,	0, INSTR, GFLAG_NO, 0),
-	PCE_MC_M(0x4000, 0xF000, 24, GOUT_IP0,	4, INSTR, GFLAG_IPV4, 1),
-	PCE_MC_M(0x6000, 0xF000, 27, GOUT_IP0,	3, INSTR, GFLAG_IPV6, 0),
-	PCE_MC_M(0x0000, 0x0000, 41, GOUT_NONE,	0, INSTR, GFLAG_NO, 0),
-	PCE_MC_M(0x0000, 0x0000, 25, GOUT_IP3,	2, INSTR, GFLAG_NO, 0),
-	PCE_MC_M(0x0000, 0x0000, 26, GOUT_SIP0,	4, INSTR, GFLAG_NO, 0),
-	PCE_MC_M(0x0000, 0x0000, 40, GOUT_NONE,	0, LENACCU, GFLAG_NO, 0),
-	PCE_MC_M(0x1100, 0xFF00, 39, GOUT_PROT,	1, INSTR, GFLAG_NO, 0),
-	PCE_MC_M(0x0600, 0xFF00, 39, GOUT_PROT,	1, INSTR, GFLAG_NO, 0),
-	PCE_MC_M(0x0000, 0xFF00, 33, GOUT_IP3,	17, INSTR, GFLAG_HOP, 0),
-	PCE_MC_M(0x2B00, 0xFF00, 33, GOUT_IP3,	17, INSTR, GFLAG_NN1, 0),
-	PCE_MC_M(0x3C00, 0xFF00, 33, GOUT_IP3,	17, INSTR, GFLAG_NN2, 0),
-	PCE_MC_M(0x0000, 0x0000, 39, GOUT_PROT,	1, INSTR, GFLAG_NO, 0),
-	PCE_MC_M(0x0000, 0x00E0, 35, GOUT_NONE, 0, INSTR, GFLAG_NO, 0),
-	PCE_MC_M(0x0000, 0x0000, 40, GOUT_NONE, 0, INSTR, GFLAG_NO, 0),
-	PCE_MC_M(0x0000, 0xFF00, 33, GOUT_NONE,	0, IPV6,  GFLAG_HOP, 0),
-	PCE_MC_M(0x2B00, 0xFF00, 33, GOUT_NONE,	0, IPV6,  GFLAG_NN1, 0),
-	PCE_MC_M(0x3C00, 0xFF00, 33, GOUT_NONE,	0, IPV6,  GFLAG_NN2, 0),
-	PCE_MC_M(0x0000, 0x0000, 40, GOUT_PROT,	1, IPV6,  GFLAG_NO, 0),
-	PCE_MC_M(0x0000, 0x0000, 40, GOUT_SIP0,	16, INSTR, GFLAG_NO, 0),
-	PCE_MC_M(0x0000, 0x0000, 41, GOUT_APP0,	4, INSTR, GFLAG_IGMP, 0),
-	PCE_MC_M(0x0000, 0x0000, 41, GOUT_NONE,	0, INSTR, GFLAG_END, 0),
-	PCE_MC_M(0x0000, 0x0000, 41, GOUT_NONE,	0, INSTR, GFLAG_END, 0),
-	PCE_MC_M(0x0000, 0x0000, 41, GOUT_NONE,	0, INSTR, GFLAG_END, 0),
-	PCE_MC_M(0x0000, 0x0000, 41, GOUT_NONE,	0, INSTR, GFLAG_END, 0),
-	PCE_MC_M(0x0000, 0x0000, 41, GOUT_NONE,	0, INSTR, GFLAG_END, 0),
-	PCE_MC_M(0x0000, 0x0000, 41, GOUT_NONE,	0, INSTR, GFLAG_END, 0),
-	PCE_MC_M(0x0000, 0x0000, 41, GOUT_NONE,	0, INSTR, GFLAG_END, 0),
-	PCE_MC_M(0x0000, 0x0000, 41, GOUT_NONE,	0, INSTR, GFLAG_END, 0),
-	PCE_MC_M(0x0000, 0x0000, 41, GOUT_NONE,	0, INSTR, GFLAG_END, 0),
-	PCE_MC_M(0x0000, 0x0000, 41, GOUT_NONE,	0, INSTR, GFLAG_END, 0),
-	PCE_MC_M(0x0000, 0x0000, 41, GOUT_NONE,	0, INSTR, GFLAG_END, 0),
-	PCE_MC_M(0x0000, 0x0000, 41, GOUT_NONE,	0, INSTR, GFLAG_END, 0),
-	PCE_MC_M(0x0000, 0x0000, 41, GOUT_NONE,	0, INSTR, GFLAG_END, 0),
-	PCE_MC_M(0x0000, 0x0000, 41, GOUT_NONE,	0, INSTR, GFLAG_END, 0),
-	PCE_MC_M(0x0000, 0x0000, 41, GOUT_NONE,	0, INSTR, GFLAG_END, 0),
-	PCE_MC_M(0x0000, 0x0000, 41, GOUT_NONE,	0, INSTR, GFLAG_END, 0),
-	PCE_MC_M(0x0000, 0x0000, 41, GOUT_NONE,	0, INSTR, GFLAG_END, 0),
-	PCE_MC_M(0x0000, 0x0000, 41, GOUT_NONE,	0, INSTR, GFLAG_END, 0),
-	PCE_MC_M(0x0000, 0x0000, 41, GOUT_NONE,	0, INSTR, GFLAG_END, 0),
-	PCE_MC_M(0x0000, 0x0000, 41, GOUT_NONE,	0, INSTR, GFLAG_END, 0),
-	PCE_MC_M(0x0000, 0x0000, 41, GOUT_NONE,	0, INSTR, GFLAG_END, 0),
-	PCE_MC_M(0x0000, 0x0000, 41, GOUT_NONE,	0, INSTR, GFLAG_END, 0),
-	PCE_MC_M(0x0000, 0x0000, 41, GOUT_NONE,	0, INSTR, GFLAG_END, 0),
+	PCE_MC_M(0x88c3, 0xFFFF, 1, GOUT_ITAG0, 4, INSTR, GFLAG_ITAG,	0),
+	PCE_MC_M(0x8100, 0xFFFF, 4, GOUT_STAG0, 2, INSTR, GFLAG_SVLAN,  0),
+	PCE_MC_M(0x88A8, 0xFFFF, 4, GOUT_STAG0, 2, INSTR, GFLAG_SVLAN,  0),
+	PCE_MC_M(0x9100, 0xFFFF, 4, GOUT_STAG0, 2, INSTR, GFLAG_SVLAN,  0),
+	PCE_MC_M(0x8100, 0xFFFF, 5, GOUT_VTAG0, 2, INSTR, GFLAG_VLAN,	0),
+	PCE_MC_M(0x88A8, 0xFFFF, 6, GOUT_VTAG0, 2, INSTR, GFLAG_VLAN,	0),
+	PCE_MC_M(0x9100, 0xFFFF, 4, GOUT_VTAG0, 2, INSTR, GFLAG_VLAN,	0),
+	PCE_MC_M(0x8864, 0xFFFF, 20, GOUT_ETHTYP, 1, INSTR, GFLAG_NO,	0),
+	PCE_MC_M(0x0800, 0xFFFF, 24, GOUT_ETHTYP, 1, INSTR, GFLAG_NO,	0),
+	PCE_MC_M(0x86DD, 0xFFFF, 25, GOUT_ETHTYP, 1, INSTR, GFLAG_NO,	0),
+	PCE_MC_M(0x8863, 0xFFFF, 19, GOUT_ETHTYP, 1, INSTR, GFLAG_NO,	0),
+	PCE_MC_M(0x0000, 0xF800, 13, GOUT_NONE, 0, INSTR, GFLAG_NO,  0),
+	PCE_MC_M(0x0000, 0x0000, 44, GOUT_ETHTYP, 1, INSTR, GFLAG_NO,	0),
+	PCE_MC_M(0x0600, 0x0600, 44, GOUT_ETHTYP, 1, INSTR, GFLAG_NO,	0),
+	PCE_MC_M(0x0000, 0x0000, 15, GOUT_NONE, 1, INSTR, GFLAG_NO,  0),
+	PCE_MC_M(0xAAAA, 0xFFFF, 17, GOUT_NONE, 1, INSTR, GFLAG_NO,  0),
+	PCE_MC_M(0x0000, 0x0000, 48, GOUT_NONE, 0, INSTR, GFLAG_NO,  0),
+	PCE_MC_M(0x0300, 0xFF00, 48, GOUT_NONE, 0, INSTR, GFLAG_SNAP,	0),
+	PCE_MC_M(0x0000, 0x0000, 48, GOUT_NONE, 0, INSTR, GFLAG_NO,  0),
+	PCE_MC_M(0x0000, 0x0000, 48, GOUT_DIP7, 3, INSTR, GFLAG_NO,  0),
+	PCE_MC_M(0x0000, 0x0000, 21, GOUT_DIP7, 3, INSTR, GFLAG_PPPOE,  0),
+	PCE_MC_M(0x0021, 0xFFFF, 24, GOUT_NONE, 1, INSTR, GFLAG_NO,  0),
+	PCE_MC_M(0x0057, 0xFFFF, 25, GOUT_NONE, 1, INSTR, GFLAG_NO,  0),
+	PCE_MC_M(0x0000, 0x0000, 44, GOUT_NONE, 0, INSTR, GFLAG_NO,  0),
+	PCE_MC_M(0x4000, 0xF000, 27, GOUT_IP0, 4, INSTR, GFLAG_IPV4, 1),
+	PCE_MC_M(0x6000, 0xF000, 30, GOUT_IP0, 3, INSTR, GFLAG_IPV6,  0),
+	PCE_MC_M(0x0000, 0x0000, 44, GOUT_NONE, 0, INSTR, GFLAG_NO,  0),
+	PCE_MC_M(0x0000, 0x0000, 28, GOUT_IP3, 2, INSTR, GFLAG_NO,  0),
+	PCE_MC_M(0x0000, 0x0000, 29, GOUT_SIP0, 4, INSTR, GFLAG_NO,  0),
+	PCE_MC_M(0x0000, 0x0000, 44, GOUT_NONE, 0, LENACCU, GFLAG_NO,	0),
+	PCE_MC_M(0x1100, 0xFF00, 43, GOUT_PROT, 1, INSTR, GFLAG_NO,  0),
+	PCE_MC_M(0x0600, 0xFF00, 43, GOUT_PROT, 1, INSTR, GFLAG_NO,  0),
+	PCE_MC_M(0x0000, 0xFF00, 41, GOUT_IP3, 17, INSTR, GFLAG_HOP,  0),
+	PCE_MC_M(0x2B00, 0xFF00, 41, GOUT_IP3, 17, INSTR, GFLAG_NO,  0),
+	PCE_MC_M(0x3C00, 0xFF00, 41, GOUT_IP3, 17, INSTR, GFLAG_NO,  0),
+	PCE_MC_M(0x0000, 0x0000, 43, GOUT_PROT, 1, INSTR, GFLAG_NO,  0),
+	PCE_MC_M(0x0000, 0xFF00, 41, GOUT_NONE, 0, IPV6, GFLAG_HOP,  0),
+	PCE_MC_M(0x2B00, 0xFF00, 41, GOUT_NONE, 0, IPV6, GFLAG_NO,  0),
+	PCE_MC_M(0x3C00, 0xFF00, 41, GOUT_NONE, 0, IPV6, GFLAG_NO,  0),
+	PCE_MC_M(0x0000, 0x00FC, 44, GOUT_PROT, 0, IPV6, GFLAG_NO,  0),
+	PCE_MC_M(0x0000, 0x0000, 44, GOUT_NONE, 0, IPV6, GFLAG_NO,  0),
+	PCE_MC_M(0x0000, 0x00F8, 36, GOUT_NONE, 0, INSTR, GFLAG_NO,  0),
+	PCE_MC_M(0x0000, 0x0000, 44, GOUT_NONE, 0, INSTR, GFLAG_NO,  0),
+	PCE_MC_M(0x0000, 0x0000, 44, GOUT_SIP0, 16, INSTR, GFLAG_NO,  0),
+	PCE_MC_M(0x0000, 0x0000, 45, GOUT_APP0, 3, INSTR, GFLAG_IGMP, 0),
+	PCE_MC_M(0x1000, 0x1000, 46, GOUT_NONE, 0, INSTR, GFLAG_NN2, 0),
+	PCE_MC_M(0x2000, 0x2000, 47, GOUT_NONE, 0, INSTR, GFLAG_NN1, 0),
+	PCE_MC_M(0x0000, 0x0000, 48, GOUT_IGMP1, 1, INSTR, GFLAG_NO, 0),
+	PCE_MC_M(0x0000, 0x0000, 48, GOUT_NONE, 0, INSTR, GFLAG_END,  0),
+	PCE_MC_M(0x0000, 0x0000, 48, GOUT_NONE, 0, INSTR, GFLAG_END,  0),
+	PCE_MC_M(0x0000, 0x0000, 48, GOUT_NONE, 0, INSTR, GFLAG_END,  0),
+	PCE_MC_M(0x0000, 0x0000, 48, GOUT_NONE, 0, INSTR, GFLAG_END,  0),
+	PCE_MC_M(0x0000, 0x0000, 48, GOUT_NONE, 0, INSTR, GFLAG_END,  0),
+	PCE_MC_M(0x0000, 0x0000, 48, GOUT_NONE, 0, INSTR, GFLAG_END,  0),
+	PCE_MC_M(0x0000, 0x0000, 48, GOUT_NONE, 0, INSTR, GFLAG_END,  0),
+	PCE_MC_M(0x0000, 0x0000, 48, GOUT_NONE, 0, INSTR, GFLAG_END,  0),
+	PCE_MC_M(0x0000, 0x0000, 48, GOUT_NONE, 0, INSTR, GFLAG_END,  0),
+	PCE_MC_M(0x0000, 0x0000, 48, GOUT_NONE, 0, INSTR, GFLAG_END,  0),
+	PCE_MC_M(0x0000, 0x0000, 48, GOUT_NONE, 0, INSTR, GFLAG_END,  0),
+	PCE_MC_M(0x0000, 0x0000, 48, GOUT_NONE, 0, INSTR, GFLAG_END,  0),
+	PCE_MC_M(0x0000, 0x0000, 48, GOUT_NONE, 0, INSTR, GFLAG_END,  0),
+	PCE_MC_M(0x0000, 0x0000, 48, GOUT_NONE, 0, INSTR, GFLAG_END,  0),
+	PCE_MC_M(0x0000, 0x0000, 48, GOUT_NONE, 0, INSTR, GFLAG_END,  0),
+	PCE_MC_M(0x0000, 0x0000, 48, GOUT_NONE, 0, INSTR, GFLAG_END,  0),
+	PCE_MC_M(0x0000, 0x0000, 48, GOUT_NONE, 0, INSTR, GFLAG_END,  0),
+	PCE_MC_M(0x0000, 0x0000, 48, GOUT_NONE, 0, INSTR, GFLAG_END,  0),
+	PCE_MC_M(0x0000, 0x0000, 48, GOUT_NONE, 0, INSTR, GFLAG_END, 0),
 };
 
 /* find a matched entry if already written or empty entry and fill */
@@ -1494,6 +1499,75 @@ int pce_table_init(ltq_pce_table_t *ptable)
 	return GSW_statusOk;
 }
 
+int gsw_pmicro_code_init_f24s(void *cdev)
+{
+	u16 i, j, cnt = 0;
+	pctbl_prog_t tbl_entry;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+
+	printk("PCE f24s micro-code init\n");
+	/* Disable all physical port  */
+
+	for (j = 0; j < gswdev->pnum; j++) {
+		printk("gswdev->pnum =%d j= %d\n", gswdev->pnum, j);
+		gsw_w32(cdev, (SDMA_PCTRL_PEN_OFFSET + (j * 0x6)),
+			SDMA_PCTRL_PEN_SHIFT, SDMA_PCTRL_PEN_SIZE, 0);
+	}
+
+	gsw_w32(cdev, PCE_GCTRL_0_MC_VALID_OFFSET,
+		PCE_GCTRL_0_MC_VALID_SHIFT, PCE_GCTRL_0_MC_VALID_SIZE, 0x0);
+
+	/* Download the microcode  */
+	for (i = 0; i < 64 /* PCE_MICRO_TABLE_SIZE */; i++) {
+		memset(&tbl_entry, 0, sizeof(tbl_entry));
+		tbl_entry.val[3] = pce_mc_max_ifx_tag_m[i].val_3;
+		tbl_entry.val[2] = pce_mc_max_ifx_tag_m[i].val_2;
+		tbl_entry.val[1] = pce_mc_max_ifx_tag_m[i].val_1;
+		tbl_entry.val[0] = pce_mc_max_ifx_tag_m[i].val_0;
+		tbl_entry.pcindex = i;
+		tbl_entry.table = PCE_PARS_INDEX;
+		gsw_pce_table_write(cdev, &tbl_entry);
+	}
+
+	gsw_w32(cdev, PCE_GCTRL_0_MC_VALID_OFFSET,
+		PCE_GCTRL_0_MC_VALID_SHIFT, PCE_GCTRL_0_MC_VALID_SIZE, 0x1);
+
+	for (j = 0; j < gswdev->pnum; j++) {
+		gsw_w32(cdev, (SDMA_PCTRL_PEN_OFFSET + (j * 0x6)),
+			SDMA_PCTRL_PEN_SHIFT, SDMA_PCTRL_PEN_SIZE, 1);
+	}
+
+	/* Enable RMON Counter for all ports */
+	for (j = 0; j < gswdev->pnum; j++) {
+		gsw_w32(cdev, (BM_PCFG_CNTEN_OFFSET + (j * 0x2)),
+			BM_PCFG_CNTEN_SHIFT, BM_PCFG_CNTEN_SIZE, 1);
+	}
+
+	gsw_w32(cdev, BM_QUEUE_GCTRL_GL_MOD_OFFSET,
+		BM_QUEUE_GCTRL_GL_MOD_SHIFT,
+		BM_QUEUE_GCTRL_GL_MOD_SIZE, 0);
+
+#if 0
+	printk("PARSER CODE DUMP\n\n");
+
+	for (i = 0; i < 64 /* PCE_MICRO_TABLE_SIZE */; i++) {
+		memset(&tbl_entry, 0, sizeof(tbl_entry));
+		tbl_entry.pcindex = i;
+		tbl_entry.table = PCE_PARS_INDEX;
+		tbl_entry.val[3] = pce_mc_max_ifx_tag_m[i].val_3;
+		tbl_entry.val[2] = pce_mc_max_ifx_tag_m[i].val_2;
+		gsw_pce_table_read(cdev, &tbl_entry);
+		printk("0x%04x , 0x%04x , 0x%04x , 0x%04x\n", tbl_entry.val[0], tbl_entry.val[1], tbl_entry.val[2], tbl_entry.val[3]);
+	}
+
+	printk("\n\nPARSER CODE DUMP Complete\n\n");
+#endif
+
+	return 0;
+}
+
+
+
 /* PCE Table Micro Code Init routine */
 int gsw_pmicro_code_init(void *cdev)
 {
@@ -1507,6 +1581,7 @@ int gsw_pmicro_code_init(void *cdev)
 		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
 		return GSW_statusErr;
 	}
+
 	if (IS_VRSN_31(gswdev->gipver))
 		no_ports = gswdev->tpnum;
 	else
@@ -1605,6 +1680,7 @@ int gsw_pmicro_code_init(void *cdev)
 	}
 
 	if ((gswdev->gipver == LTQ_GSWIP_2_2) ||
+	    (gswdev->gipver == LTQ_GSWIP_2_2_ETC) ||
 	    (gswdev->gipver == LTQ_GSWIP_3_0) ||
 	    (IS_VRSN_31(gswdev->gipver)))
 		Gl_Mod_Size = BM_QUEUE_GCTRL_GL_MOD_SIZE2;
@@ -1628,7 +1704,7 @@ int pce_action_delete(void *cdev, ltq_pce_table_t *pthandle, u32 index)
 		return GSW_statusErr;
 	}
 
-	PCE_ASSERT(index >= PCE_TABLE_SIZE);
+	PCE_ASSERT(index >= (gswdev->tftblsize));
 	memset(&ptbl, 0, sizeof(pctbl_prog_t));
 	memset(&pthandle->pce_act[index], 0, sizeof(GSW_PCE_action_t));
 	/* Remove rule action from HW */
@@ -1673,7 +1749,7 @@ int pce_pattern_delete(void *cdev, ltq_pce_table_t *pthandle, u32 index)
 		return GSW_statusErr;
 	}
 
-	PCE_ASSERT(index >= PCE_TABLE_SIZE);
+	PCE_ASSERT(index >= (gswdev->tftblsize));
 
 	/* Check if an entry is currently programmed and remove it. */
 	if (pthandle->ptblused[index] == 0)
@@ -1707,12 +1783,16 @@ int pce_pattern_delete(void *cdev, ltq_pce_table_t *pthandle, u32 index)
 	/* Parer flags field */
 	IFX_PCE_TM_IDX_DELETE(0xFF, ptable->parse1_msb_idx,
 			      pce_tm_flags_tbl_delete)
-	/* Payload1 field */
-	IFX_PCE_TM_IDX_DELETE(0xFF, ptable->payload1_idx,
-			      pce_tm_payload_tbl_delete)
-	/* payload2 field */
-	IFX_PCE_TM_IDX_DELETE(0xFF, ptable->payload2_idx,
-			      pce_tm_payload_tbl_delete)
+
+	if (IS_VRSN_30_31(gswdev->gipver)) {
+		/* Payload1 field */
+		IFX_PCE_TM_IDX_DELETE(0xFF, ptable->payload1_idx,
+				      pce_tm_payload_tbl_delete)
+		/* payload2 field */
+		IFX_PCE_TM_IDX_DELETE(0xFF, ptable->payload2_idx,
+				      pce_tm_payload_tbl_delete)
+	}
+
 	/* DIP MSB */
 	IFX_PCE_TM_IDX_DELETE(0xFF, ptable->dip_msb_idx,
 			      ip_dasa_msb_tbl_del)
@@ -1776,7 +1856,7 @@ int pce_rule_read(void *cdev, ltq_pce_table_t *pthandle, GSW_PCE_rule_t *parm)
 	u32   i, j, idx = parm->pattern.nIndex;
 	pce_table_t  *ptable;
 	static pctbl_prog_t ptbl;
-	PCE_ASSERT(idx >= PCE_TABLE_SIZE);
+	PCE_ASSERT(idx >= (gswdev->tftblsize));
 	/* Initialize to zero */
 	memset(parm, 0, sizeof(GSW_PCE_rule_t));
 	memset(&ptbl, 0, sizeof(pctbl_prog_t));
@@ -1792,7 +1872,7 @@ int pce_rule_read(void *cdev, ltq_pce_table_t *pthandle, GSW_PCE_rule_t *parm)
 	gsw_pce_table_read(cdev, &ptbl); //Read given entry
 
 	/* Exclude flags */
-	if (gswdev->gipver == LTQ_GSWIP_3_0 || IS_VRSN_31(gswdev->gipver)) {
+	if (IS_VRSN_30_31(gswdev->gipver)) {
 		if ((ptbl.key[15] >> 0) & 0x1)
 			parm->pattern.bDstMAC_Exclude = 1;
 
@@ -1906,12 +1986,12 @@ int pce_rule_read(void *cdev, ltq_pce_table_t *pthandle, GSW_PCE_rule_t *parm)
 	}
 
 	/* Port ID field value */
-	if (gswdev->gipver == LTQ_GSWIP_3_0 || IS_VRSN_31(gswdev->gipver)) {
+	if (gswdev->gipver >= LTQ_GSWIP_3_0) {
 		if ((ptbl.key[0] & 0x1F) != 0x1F) { //Is pattern enabled?
 			parm->pattern.nPortId = ptbl.key[0] & 0xF;
 			parm->pattern.bPortIdEnable = 1;
 		}
-	} else if (gswdev->gipver == LTQ_GSWIP_2_2) {
+	} else if (gswdev->gipver <= LTQ_GSWIP_2_2_ETC) {
 		if ((ptbl.key[0] & 0xF) != 0xF) { //Is pattern enabled?
 			parm->pattern.nPortId = ptbl.key[0] & 0x7;
 			parm->pattern.bPortIdEnable = 1;
@@ -1924,7 +2004,36 @@ int pce_rule_read(void *cdev, ltq_pce_table_t *pthandle, GSW_PCE_rule_t *parm)
 		parm->pattern.bDSCP_Enable = 1;
 	}
 
-	if (gswdev->gipver == LTQ_GSWIP_3_0 || IS_VRSN_31(gswdev->gipver)) {
+	/* Applicable for 3.0 or less*/
+	if (gswdev->gipver <= LTQ_GSWIP_3_0) {
+		if (ptbl.val[0] & 0x1) { //If port-map action set.
+			if (ptbl.val[1] == 0x0) { //If port-map IDs not set.
+				if (((ptbl.val[4] >> 2) & 0x3) == 0x3) {
+					//If port-map type is 'tflow'.
+					parm->action.ePortMapAction =
+						GSW_PCE_ACTION_PORTMAP_DISCARD;
+				} else if (((ptbl.val[4] >> 2) & 0x3) == 0x0) {
+					//If port-map type is 'default'.
+					parm->action.ePortMapAction =
+						GSW_PCE_ACTION_PORTMAP_REGULAR;
+				}
+			} else if (ptbl.val[1] != 0x0) { //If port-map IDs set.
+				parm->action.nForwardPortMap[0] = ptbl.val[1];
+
+				if (((ptbl.val[4] >> 2) & 0x3) == 0x3) {
+					//If port-map type is 'tflow'.
+					parm->action.ePortMapAction =
+						GSW_PCE_ACTION_PORTMAP_ALTERNATIVE;
+				} else if ((((ptbl.val[4] >> 2) & 0x3) == 0x1)) {
+					//If port-map type is 'MC router'.
+					parm->action.ePortMapAction =
+						GSW_PCE_ACTION_PORTMAP_CPU;
+				}
+			}
+		}
+	}
+
+	if (IS_VRSN_30_31(gswdev->gipver)) {
 		/* Inner DSCP field value */
 		if (((ptbl.key[9] >> 8) & 0x7F) != 0x7F) { //Is pattern enabled?
 			parm->pattern.nInnerDSCP = (ptbl.key[9] >> 8) & 0x3F;
@@ -1953,232 +2062,208 @@ int pce_rule_read(void *cdev, ltq_pce_table_t *pthandle, GSW_PCE_rule_t *parm)
 		if (ptbl.val[8] & 0x1)
 			parm->action.eProcessPath_Action = (ptbl.val[8] >> 1) & 0x3;
 
-		/* L3 Routing type action value */
-		if (gswdev->gipver == LTQ_GSWIP_3_0) {
-			if (gswdev->sdev == LTQ_FLOW_DEV_INT_R) {
-				parm->action.bRtCtrlEna_Action = ptbl.val[9] & 0x1;
-				parm->action.bRtAccelEna_Action = (ptbl.val[9] >> 1) & 0x1;
-				parm->action.bRtInnerIPasKey_Action = (ptbl.val[9] >> 2) & 0x1;
+	}
 
-				if ((ptbl.val[9] >> 3) & 0x1)
-					parm->action.bRtSrcIpMaskCmp_Action = 0;
-				else
-					parm->action.bRtSrcIpMaskCmp_Action = 1;
 
-				if ((ptbl.val[9] >> 4) & 0x1)
-					parm->action.bRtDstIpMaskCmp_Action = 0;
-				else
-					parm->action.bRtDstIpMaskCmp_Action = 1;
+	/* L3 Routing type action value */
+	if (gswdev->gipver == LTQ_GSWIP_3_0) {
+		if (gswdev->sdev == LTQ_FLOW_DEV_INT_R) {
+			parm->action.bRtCtrlEna_Action = ptbl.val[9] & 0x1;
+			parm->action.bRtAccelEna_Action = (ptbl.val[9] >> 1) & 0x1;
+			parm->action.bRtInnerIPasKey_Action = (ptbl.val[9] >> 2) & 0x1;
 
-				if ((ptbl.val[9] >> 5) & 0x1)
-					parm->action.bRtSrcPortMaskCmp_Action = 0;
-				else
-					parm->action.bRtSrcPortMaskCmp_Action = 1;
+			if ((ptbl.val[9] >> 3) & 0x1)
+				parm->action.bRtSrcIpMaskCmp_Action = 0;
+			else
+				parm->action.bRtSrcIpMaskCmp_Action = 1;
 
-				if ((ptbl.val[9] >> 6) & 0x1)
-					parm->action.bRtDstPortMaskCmp_Action = 0;
-				else
-					parm->action.bRtDstPortMaskCmp_Action = 1;
+			if ((ptbl.val[9] >> 4) & 0x1)
+				parm->action.bRtDstIpMaskCmp_Action = 0;
+			else
+				parm->action.bRtDstIpMaskCmp_Action = 1;
 
-				if (((ptbl.val[9] >> 8) & 0xFF) != 0xFF) {
-					parm->action.bRoutExtId_Action = 1;
-					parm->action.nRoutExtId = (ptbl.val[9] >> 8) & 0xFF;
-				}
-			}
+			if ((ptbl.val[9] >> 5) & 0x1)
+				parm->action.bRtSrcPortMaskCmp_Action = 0;
+			else
+				parm->action.bRtSrcPortMaskCmp_Action = 1;
+
+			if ((ptbl.val[9] >> 6) & 0x1)
+				parm->action.bRtDstPortMaskCmp_Action = 0;
+			else
+				parm->action.bRtDstPortMaskCmp_Action = 1;
 
-			/* Flow ID action value */
-			if ((ptbl.val[4] >> 4) & 0x1) {
-				parm->action.bFlowID_Action = 1;
-				parm->action.nFlowID = ptbl.val[1];
+			if (((ptbl.val[9] >> 8) & 0xFF) != 0xFF) {
+				parm->action.bRoutExtId_Action = 1;
+				parm->action.nRoutExtId = (ptbl.val[9] >> 8) & 0xFF;
 			}
 		}
 
-		/* Trunk port, port link selection action value */
-		parm->action.bPortLinkSelection = (ptbl.val[5] >> 1) & 0x1;
-		parm->action.bPortTrunkAction = (ptbl.val[5] >> 0) & 0x1;
-
-		/* Cross VLAN action value */
-		if ((ptbl.val[0] >> 4) & 0x1) {
-			if ((ptbl.val[3] >> 15) & 0x1)
-				parm->action.eVLAN_CrossAction =
-					GSW_PCE_ACTION_CROSS_VLAN_CROSS;
-			else
-				parm->action.eVLAN_CrossAction =
-					GSW_PCE_ACTION_CROSS_VLAN_REGULAR;
+		/* Flow ID action value */
+		if ((ptbl.val[4] >> 4) & 0x1) {
+			parm->action.bFlowID_Action = 1;
+			parm->action.nFlowID = ptbl.val[1];
 		}
+	}
 
-		/* Applicable for 3.0*/
-		if (gswdev->gipver == LTQ_GSWIP_3_0) {
-			parm->action.bPortBitMapMuxControl = (ptbl.val[6] >> 0) & 0x1;
+	/* Trunk port, port link selection action value */
+	parm->action.bPortLinkSelection = (ptbl.val[5] >> 1) & 0x1;
+	parm->action.bPortTrunkAction = (ptbl.val[5] >> 0) & 0x1;
 
-			if (parm->action.bPortBitMapMuxControl)
-				parm->action.nForwardPortMap[0] = ptbl.val[1];
+	/* Cross VLAN action value */
+	if ((ptbl.val[0] >> 4) & 0x1) {
+		if ((ptbl.val[3] >> 15) & 0x1)
+			parm->action.eVLAN_CrossAction =
+				GSW_PCE_ACTION_CROSS_VLAN_CROSS;
+		else
+			parm->action.eVLAN_CrossAction =
+				GSW_PCE_ACTION_CROSS_VLAN_REGULAR;
+	}
+
+	/* Applicable for 3.0*/
+	if (gswdev->gipver == LTQ_GSWIP_3_0) {
+		parm->action.bPortBitMapMuxControl = (ptbl.val[6] >> 0) & 0x1;
 
-			if (((ptbl.val[5] >> 2) & 0x1) 	&& ((ptbl.val[0] >> 1) & 0x1))
-				parm->action.bCVLAN_Ignore_Control = 1;
+		if (parm->action.bPortBitMapMuxControl)
+			parm->action.nForwardPortMap[0] = ptbl.val[1];
 
-			if ((ptbl.val[0] >> 1) & 0x1) {
-				parm->action.eSVLAN_Action = 1;
-				parm->action.nSVLAN_Id = (ptbl.val[6] >> 4) & 0xFFF;
-				//parm->action.nFId = ((ptbl.val[2] >> 8) & 0xFF);
-			}
+		if (((ptbl.val[5] >> 2) & 0x1) 	&& ((ptbl.val[0] >> 1) & 0x1))
+			parm->action.bCVLAN_Ignore_Control = 1;
 
-			if ((ptbl.val[0] >> 1) & 0x1) { //Govind - 3.0 same flag for both eVLAN_Action n eSVLAN_Action?
-				parm->action.eVLAN_Action = 1;
-				parm->action.nVLAN_Id = (ptbl.val[5] >> 4) & 0xFFF;
-				parm->action.nFId = ((ptbl.val[2] >> 8) & 0xFF);
-			}
+		if ((ptbl.val[0] >> 1) & 0x1) {
+			parm->action.eSVLAN_Action = 1;
+			parm->action.nSVLAN_Id = (ptbl.val[6] >> 4) & 0xFFF;
+			//parm->action.nFId = ((ptbl.val[2] >> 8) & 0xFF);
 		}
 
-		//Extended VLAN tagging action.
-		if (IS_VRSN_31(gswdev->gipver)) {
-			if ((ptbl.val[6] >> 3) & 0x1) {
-				parm->action.bExtendedVlanEnable = 1; //Enable extended VLAN tagging.
-				parm->action.nExtendedVlanBlockId = (ptbl.val[6] >> 4) & 0x3FF;
-			}
+		if ((ptbl.val[0] >> 1) & 0x1) { //Govind - 3.0 same flag for both eVLAN_Action n eSVLAN_Action?
+			parm->action.eVLAN_Action = 1;
+			parm->action.nVLAN_Id = (ptbl.val[5] >> 4) & 0xFFF;
+			parm->action.nFId = ((ptbl.val[2] >> 8) & 0xFF);
 		}
+	}
 
-		/* Applicable for 3.0*/
-		if (IS_VRSN_NOT_31(gswdev->gipver)) {
-			if ((ptbl.val[0] >> 12) & 0x1) {
-				parm->action.bRMON_Action = 1;
-				parm->action.nRMON_Id = (((ptbl.val[4] >> 8) & 0x1F) - 1);
-			}
+	//Extended VLAN tagging action.
+	if (IS_VRSN_31(gswdev->gipver)) {
+		if ((ptbl.val[6] >> 3) & 0x1) {
+			parm->action.bExtendedVlanEnable = 1; //Enable extended VLAN tagging.
+			parm->action.nExtendedVlanBlockId = (ptbl.val[6] >> 4) & 0x3FF;
+		}
+	}
 
-			if ((ptbl.val[0] >> 11) & 0x1) {
-				parm->action.eMeterAction = (ptbl.val[3] >> 6) & 0x3;
-				parm->action.nMeterId = ptbl.val[3] & 0x1F;
-			}
+	/* Applicable for 3.0*/
+	if (IS_VRSN_NOT_31(gswdev->gipver)) {
+		if ((ptbl.val[0] >> 12) & 0x1) {
+			parm->action.bRMON_Action = 1;
+			parm->action.nRMON_Id = (((ptbl.val[4] >> 8) & 0x1F) - 1);
+		}
 
-			if (!((ptbl.val[3] >> 13) & 0x1))
-				parm->action.bRemarkClass = 1;
+		if ((ptbl.val[0] >> 11) & 0x1) {
+			parm->action.eMeterAction = (ptbl.val[3] >> 6) & 0x3;
+			parm->action.nMeterId = ptbl.val[3] & 0x1F;
+		}
 
-			if (!((ptbl.val[3] >> 12) & 0x1))
-				parm->action.bRemarkDSCP = 1;
+		if (!((ptbl.val[3] >> 13) & 0x1))
+			parm->action.bRemarkClass = 1;
 
-			if (!((ptbl.val[6] >> 2) & 0x1))
-				parm->action.bRemarkSTAG_DEI = 1;
+		if (!((ptbl.val[3] >> 12) & 0x1))
+			parm->action.bRemarkDSCP = 1;
 
-			if (!((ptbl.val[6] >> 1) & 0x1))
-				parm->action.bRemarkSTAG_PCP = 1;
+		if (!((ptbl.val[6] >> 2) & 0x1))
+			parm->action.bRemarkSTAG_DEI = 1;
 
-			if (!((ptbl.val[3] >> 14) & 0x1))
-				parm->action.bRemarkPCP = 1;
+		if (!((ptbl.val[6] >> 1) & 0x1))
+			parm->action.bRemarkSTAG_PCP = 1;
 
-			if ((ptbl.val[0] >> 3) & 0x1)
-				parm->action.bRemarkAction = 1;
+		if (!((ptbl.val[3] >> 14) & 0x1))
+			parm->action.bRemarkPCP = 1;
 
-			if ((ptbl.val[0] >> 6) & 0x1) {
-				if ((ptbl.val[4] >> 14) & 0x1)
-					parm->action.eCritFrameAction =
-						GSW_PCE_ACTION_CRITICAL_FRAME_CRITICAL;
-				else
-					parm->action.eCritFrameAction =
-						GSW_PCE_ACTION_CRITICAL_FRAME_REGULAR;
-			}
-		}
+		if ((ptbl.val[0] >> 3) & 0x1)
+			parm->action.bRemarkAction = 1;
 
-		/* RMON counter action value */
-		if (IS_VRSN_31(gswdev->gipver)) {
-			if ((ptbl.val[4] >> 4) & 0x1) {
-				parm->action.bRMON_Action = parm->action.bFlowID_Action = 1;
-				parm->action.nRMON_Id = parm->action.nFlowID =
-								ptbl.val[1] & 0xFF;
-			}
+		if ((ptbl.val[0] >> 6) & 0x1) {
+			if ((ptbl.val[4] >> 14) & 0x1)
+				parm->action.eCritFrameAction =
+					GSW_PCE_ACTION_CRITICAL_FRAME_CRITICAL;
+			else
+				parm->action.eCritFrameAction =
+					GSW_PCE_ACTION_CRITICAL_FRAME_REGULAR;
+		}
+	}
 
-			/* Metering and counter action value */
-			if ((ptbl.val[0] >> 11) & 0x1) {
-				if ((ptbl.val[3] >> 7) & 0x1) {
-					parm->action.eMeterAction = GSW_PCE_ACTION_METER_1;
-					parm->action.nMeterId = ptbl.val[3] & 0x7F;
-				} else {
-					parm->action.eMeterAction = GSW_PCE_ACTION_METER_REGULAR;
-				}
-			}
+	/* RMON counter action value */
+	if (IS_VRSN_31(gswdev->gipver)) {
+		if ((ptbl.val[4] >> 4) & 0x1) {
+			parm->action.bRMON_Action = parm->action.bFlowID_Action = 1;
+			parm->action.nRMON_Id = parm->action.nFlowID =
+							ptbl.val[1] & 0xFF;
+		}
 
-			/* FID action control */
-			if ((ptbl.val[5] >> 3) & 0x1) {
-				parm->action.bFidEnable = 1;
-				parm->action.nFId = (ptbl.val[2] >> 8) & 0x3F;
+		/* Metering and counter action value */
+		if ((ptbl.val[0] >> 11) & 0x1) {
+			if ((ptbl.val[3] >> 7) & 0x1) {
+				parm->action.eMeterAction = GSW_PCE_ACTION_METER_1;
+				parm->action.nMeterId = ptbl.val[3] & 0x7F;
+			} else {
+				parm->action.eMeterAction = GSW_PCE_ACTION_METER_REGULAR;
 			}
 		}
 
-		/* Applicable for 3.0*/
-		if (gswdev->gipver == LTQ_GSWIP_3_0) {
-			if (ptbl.val[0] & 0x1) { //If port-map action set.
-				if (ptbl.val[1] == 0x0) { //If port-map IDs not set.
-					if (((ptbl.val[4] >> 2) & 0x3) == 0x3) {
-						//If port-map type is 'tflow'.
-						parm->action.ePortMapAction =
-							GSW_PCE_ACTION_PORTMAP_DISCARD;
-					} else if (((ptbl.val[4] >> 2) & 0x3) == 0x0) {
-						//If port-map type is 'default'.
-						parm->action.ePortMapAction =
-							GSW_PCE_ACTION_PORTMAP_REGULAR;
-					}
-				} else if (ptbl.val[1] != 0x0) { //If port-map IDs set.
-					parm->action.nForwardPortMap[0] = ptbl.val[1];
-
-					if (((ptbl.val[4] >> 2) & 0x3) == 0x3) {
-						//If port-map type is 'tflow'.
-						parm->action.ePortMapAction =
-							GSW_PCE_ACTION_PORTMAP_ALTERNATIVE;
-					} else if ((((ptbl.val[4] >> 2) & 0x3) == 0x1)) {
-						//If port-map type is 'MC router'.
-						parm->action.ePortMapAction =
-							GSW_PCE_ACTION_PORTMAP_CPU;
-					}
-				}
-			}
+		/* FID action control */
+		if ((ptbl.val[5] >> 3) & 0x1) {
+			parm->action.bFidEnable = 1;
+			parm->action.nFId = (ptbl.val[2] >> 8) & 0x3F;
 		}
+	}
 
-		/* Applicable for 3.1*/
-		if (IS_VRSN_31(gswdev->gipver)) {
-			if (ptbl.val[0] & 0x1) { //If port-map action set.
-				if (!(ptbl.val[10]) && !(ptbl.val[11]) && !(ptbl.val[12]) &&
-				    !(ptbl.val[13]) && !(ptbl.val[14]) && !(ptbl.val[15]) &&
-				    !(ptbl.val[16]) && !(ptbl.val[17])) {
-					//If port-map IDs not set.
-					if (((ptbl.val[4] >> 2) & 0x3) == 0x3) {
-						//If port-map type is 'tflow'.
-						parm->action.ePortMapAction =
-							GSW_PCE_ACTION_PORTMAP_DISCARD;
-					} else if (((ptbl.val[4] >> 2) & 0x3) == 0x0) {
-						//If port-map type is 'default'.
-						parm->action.ePortMapAction =
-							GSW_PCE_ACTION_PORTMAP_REGULAR;
-					}
-				} else if (((ptbl.val[10]) || (ptbl.val[11]) || (ptbl.val[12])) &&
-					   ((ptbl.val[13]) || (ptbl.val[14]) || (ptbl.val[15])) &&
-					   ((ptbl.val[16]) || (ptbl.val[17]))) {
-					/* It is 'traffic-flow' portmap type */
-					for (i = 0; i <= 7; i++)
-						parm->action.nForwardPortMap[i] = ptbl.val[i + 10];
-
-					if (((ptbl.val[4] >> 2) & 0x3) == 0x3) {
-						//If port-map type is 'tflow'.
-						parm->action.ePortMapAction =
-							GSW_PCE_ACTION_PORTMAP_ALTERNATIVE;
-					} else if (((ptbl.val[4] >> 2) & 0x3) == 0x1) {
-						//If port-map type is 'MC router'.
-						parm->action.ePortMapAction =
-							GSW_PCE_ACTION_PORTMAP_CPU;
-					}
+	/* Applicable for 3.1*/
+	if (IS_VRSN_31(gswdev->gipver)) {
+		if (ptbl.val[0] & 0x1) { //If port-map action set.
+			if (!(ptbl.val[10]) && !(ptbl.val[11]) && !(ptbl.val[12]) &&
+			    !(ptbl.val[13]) && !(ptbl.val[14]) && !(ptbl.val[15]) &&
+			    !(ptbl.val[16]) && !(ptbl.val[17])) {
+				//If port-map IDs not set.
+				if (((ptbl.val[4] >> 2) & 0x3) == 0x3) {
+					//If port-map type is 'tflow'.
+					parm->action.ePortMapAction =
+						GSW_PCE_ACTION_PORTMAP_DISCARD;
+				} else if (((ptbl.val[4] >> 2) & 0x3) == 0x0) {
+					//If port-map type is 'default'.
+					parm->action.ePortMapAction =
+						GSW_PCE_ACTION_PORTMAP_REGULAR;
+				}
+			} else if (((ptbl.val[10]) || (ptbl.val[11]) || (ptbl.val[12])) ||
+				   ((ptbl.val[13]) || (ptbl.val[14]) || (ptbl.val[15])) ||
+				   ((ptbl.val[16]) || (ptbl.val[17]))) {
+				/* It is 'traffic-flow' portmap type */
+				for (i = 0; i <= 7; i++)
+					parm->action.nForwardPortMap[i] = ptbl.val[i + 10];
+
+				if (((ptbl.val[4] >> 2) & 0x3) == 0x3) {
+					//If port-map type is 'tflow'.
+					parm->action.ePortMapAction =
+						GSW_PCE_ACTION_PORTMAP_ALTERNATIVE;
+				} else if (((ptbl.val[4] >> 2) & 0x3) == 0x1) {
+					//If port-map type is 'MC router'.
+					parm->action.ePortMapAction =
+						GSW_PCE_ACTION_PORTMAP_CPU;
 				}
 			}
 		}
+	}
 
-		/* Color action */
-		if (IS_VRSN_31(gswdev->gipver)) {
-			if ((ptbl.val[0] >> 6) & 0x1) {
-				if ((ptbl.val[2] & 0x7) < 4) {
-					parm->action.eColorFrameAction =
-						GSW_PCE_ACTION_COLOR_FRAME_NO_CHANGE;
-				} else {
-					parm->action.eColorFrameAction = (ptbl.val[2] & 0x7) - 2;
-				}
+	/* Color action */
+	if (IS_VRSN_31(gswdev->gipver)) {
+		if ((ptbl.val[0] >> 6) & 0x1) {
+			if ((ptbl.val[2] & 0x7) < 4) {
+				parm->action.eColorFrameAction =
+					GSW_PCE_ACTION_COLOR_FRAME_NO_CHANGE;
+			} else {
+				parm->action.eColorFrameAction = (ptbl.val[2] & 0x7) - 2;
 			}
 		}
+	}
+
+	if (IS_VRSN_30_31(gswdev->gipver)) {
 
 		/* TS action control */
 		if ((ptbl.val[0] >> 7) & 0x1) {
@@ -2191,6 +2276,7 @@ int pce_rule_read(void *cdev, ltq_pce_table_t *pthandle, GSW_PCE_rule_t *parm)
 		} else
 			parm->action.eTimestampAction = GSW_PCE_ACTION_TIMESTAMP_DISABLE;
 
+
 		/* Cross state action control */
 		if ((ptbl.val[0] >> 5) & 0x1) {
 			if ((ptbl.val[4] >> 13) & 0x1)
@@ -2211,30 +2297,32 @@ int pce_rule_read(void *cdev, ltq_pce_table_t *pthandle, GSW_PCE_rule_t *parm)
 		} else
 			parm->action.eIrqAction = GSW_PCE_ACTION_IRQ_DISABLE;
 
-		/* MAC learning action control */
-		if ((ptbl.val[0] >> 9) & 0x1) {
-			if (((ptbl.val[4]) & 0x3) == 0)
-				parm->action.eLearningAction = GSW_PCE_ACTION_LEARNING_REGULAR;
-			else if (((ptbl.val[4]) & 0x3) == 1)
-				parm->action.eLearningAction = GSW_PCE_ACTION_LEARNING_DISABLE;
-			else
-				parm->action.eLearningAction = (ptbl.val[4]) & 0x3;
-		}
+	}
 
-		/* IGMP snooping action control */
-		if ((ptbl.val[0] >> 10) & 0x1)
-			parm->action.eSnoopingTypeAction = ((ptbl.val[4] >> 5) & 0x7) + 1;
 
-		/* Traffic class action control */
-		if ((ptbl.val[0] >> 2) & 1) {
-			if ((ptbl.val[0] >> 14) & 1) {
-				parm->action.eTrafficClassAction =
-					GSW_PCE_ACTION_TRAFFIC_CLASS_ALTERNATIVE;
-				parm->action.nTrafficClassAlternate = (ptbl.val[3] >> 8) & 0xF;
-			} else
-				parm->action.eTrafficClassAction =
-					GSW_PCE_ACTION_TRAFFIC_CLASS_REGULAR;
-		}
+	/* MAC learning action control */
+	if ((ptbl.val[0] >> 9) & 0x1) {
+		if (((ptbl.val[4]) & 0x3) == 0)
+			parm->action.eLearningAction = GSW_PCE_ACTION_LEARNING_REGULAR;
+		else if (((ptbl.val[4]) & 0x3) == 1)
+			parm->action.eLearningAction = GSW_PCE_ACTION_LEARNING_DISABLE;
+		else
+			parm->action.eLearningAction = (ptbl.val[4]) & 0x3;
+	}
+
+	/* IGMP snooping action control */
+	if ((ptbl.val[0] >> 10) & 0x1)
+		parm->action.eSnoopingTypeAction = ((ptbl.val[4] >> 5) & 0x7) + 1;
+
+	/* Traffic class action control */
+	if ((ptbl.val[0] >> 2) & 1) {
+		if ((ptbl.val[0] >> 14) & 1) {
+			parm->action.eTrafficClassAction =
+				GSW_PCE_ACTION_TRAFFIC_CLASS_ALTERNATIVE;
+			parm->action.nTrafficClassAlternate = (ptbl.val[3] >> 8) & 0xF;
+		} else
+			parm->action.eTrafficClassAction =
+				GSW_PCE_ACTION_TRAFFIC_CLASS_REGULAR;
 	}
 
 	/* Inner CoS & DEI field value for 3.0 */
@@ -2318,44 +2406,6 @@ int pce_rule_read(void *cdev, ltq_pce_table_t *pthandle, GSW_PCE_rule_t *parm)
 		parm->pattern.nMAC_SrcMask = sa_mac_tbl.mac_mask;
 	}
 
-	/* Payload1 field table */
-	if (ptable->payload1_idx != 0xFF) { //Is table enabled?
-		payload_tbl_t payload_tbl;
-		memset(&payload_tbl, 0, sizeof(payload_tbl_t));
-
-		if (0 != pce_tm_payload_tbl_read(&pthandle->pce_sub_tbl,
-						 ptable->payload1_idx, &payload_tbl))
-			GSW_RETURN_PCE;
-
-		/* Destination Application used */
-		parm->pattern.bPayload1_SrcEnable = 1;
-		/* Destination Application field */
-		parm->pattern.nPayload1 = payload_tbl.payload_data;
-		/* Payload  mask/range used */
-		parm->pattern.bPayload1MaskRange_Select = payload_tbl.mask_range_type;
-		/* Payload  mask/range */
-		parm->pattern.nPayload1_Mask = payload_tbl.mask_range;
-	}
-
-	/* Payload2 field table */
-	if (ptable->payload2_idx != 0xFF) { //Is table enabled?
-		payload_tbl_t payload_tbl;
-		memset(&payload_tbl, 0, sizeof(payload_tbl_t));
-
-		if (0 != pce_tm_payload_tbl_read(&pthandle->pce_sub_tbl,
-						 ptable->payload2_idx, &payload_tbl))
-			GSW_RETURN_PCE;
-
-		/* Destination Application used */
-		parm->pattern.bPayload2_SrcEnable = 1;
-		/* Destination Application field */
-		parm->pattern.nPayload2 = payload_tbl.payload_data;
-		/* Payload  mask/range used */
-		parm->pattern.bPayload2MaskRange_Select = payload_tbl.mask_range_type;
-		/* Payload  mask/range */
-		parm->pattern.nPayload2_Mask = payload_tbl.mask_range;
-	}
-
 	/* Application field table */
 	if (ptable->dst_appl_fld_idx != 0xFF) { //Is table enabled?
 		app_tbl_t appl_tbl;
@@ -2395,7 +2445,7 @@ int pce_rule_read(void *cdev, ltq_pce_table_t *pthandle, GSW_PCE_rule_t *parm)
 	}
 
 	/* Parser flags field table */
-	if (gswdev->gipver == LTQ_GSWIP_3_0 || IS_VRSN_31(gswdev->gipver)) {
+	if (IS_VRSN_30_31(gswdev->gipver)) {
 		if (ptable->parse_lsb_idx != 0xFF) { //Is table enabled?
 			flag_tbl_t flags_tbl;
 			memset(&flags_tbl, 0, sizeof(flag_tbl_t));
@@ -2422,6 +2472,44 @@ int pce_rule_read(void *cdev, ltq_pce_table_t *pthandle, GSW_PCE_rule_t *parm)
 			parm->pattern.nParserFlagMSB_Mask = flags_tbl.mask_value;
 		}
 
+		/* Payload1 field table */
+		if (ptable->payload1_idx != 0xFF) { //Is table enabled?
+			payload_tbl_t payload_tbl;
+			memset(&payload_tbl, 0, sizeof(payload_tbl_t));
+
+			if (0 != pce_tm_payload_tbl_read(&pthandle->pce_sub_tbl,
+							 ptable->payload1_idx, &payload_tbl))
+				GSW_RETURN_PCE;
+
+			/* Destination Application used */
+			parm->pattern.bPayload1_SrcEnable = 1;
+			/* Destination Application field */
+			parm->pattern.nPayload1 = payload_tbl.payload_data;
+			/* Payload	mask/range used */
+			parm->pattern.bPayload1MaskRange_Select = payload_tbl.mask_range_type;
+			/* Payload	mask/range */
+			parm->pattern.nPayload1_Mask = payload_tbl.mask_range;
+		}
+
+		/* Payload2 field table */
+		if (ptable->payload2_idx != 0xFF) { //Is table enabled?
+			payload_tbl_t payload_tbl;
+			memset(&payload_tbl, 0, sizeof(payload_tbl_t));
+
+			if (0 != pce_tm_payload_tbl_read(&pthandle->pce_sub_tbl,
+							 ptable->payload2_idx, &payload_tbl))
+				GSW_RETURN_PCE;
+
+			/* Destination Application used */
+			parm->pattern.bPayload2_SrcEnable = 1;
+			/* Destination Application field */
+			parm->pattern.nPayload2 = payload_tbl.payload_data;
+			/* Payload	mask/range used */
+			parm->pattern.bPayload2MaskRange_Select = payload_tbl.mask_range_type;
+			/* Payload	mask/range */
+			parm->pattern.nPayload2_Mask = payload_tbl.mask_range;
+		}
+
 		/* Parser flags field table extend */
 		if (IS_VRSN_31(gswdev->gipver)) {
 			if (ptable->parse1_lsb_idx != 0xFF) { //Is table enabled?
@@ -2450,11 +2538,7 @@ int pce_rule_read(void *cdev, ltq_pce_table_t *pthandle, GSW_PCE_rule_t *parm)
 				parm->pattern.nParserFlag1MSB_Mask = flags_tbl.mask_value;
 			}
 		}
-	}
 
-	/* Inner DIP n SIP field table */
-	if ((gswdev->gipver == LTQ_GSWIP_3_0) ||
-	    (IS_VRSN_31(gswdev->gipver))) {
 		/* DIP field table */
 		if ((ptable->inr_dip_msb_idx != 0xFF)
 		    && (ptable->inr_dip_lsb_idx != 0xFF)) { //IPv6
@@ -2647,7 +2731,7 @@ int pce_rule_read(void *cdev, ltq_pce_table_t *pthandle, GSW_PCE_rule_t *parm)
 							(1 << ((i * 4) + j + 16));
 				}
 			}
-		} else if (gswdev->gipver == LTQ_GSWIP_2_2)
+		} else if ((gswdev->gipver == LTQ_GSWIP_2_2) || (gswdev->gipver == LTQ_GSWIP_2_2_ETC))
 			parm->pattern.nDstIP_Mask = dasa_tbl.mask[0] << 16;
 
 		/* DIP LS8B used */
@@ -2673,7 +2757,7 @@ int pce_rule_read(void *cdev, ltq_pce_table_t *pthandle, GSW_PCE_rule_t *parm)
 							(1 << ((i * 4) + j));
 				}
 			}
-		} else if (gswdev->gipver == LTQ_GSWIP_2_2)
+		} else if ((gswdev->gipver == LTQ_GSWIP_2_2) || (gswdev->gipver == LTQ_GSWIP_2_2_ETC))
 			parm->pattern.nDstIP_Mask |= dasa_tbl_lsb.mask[0];
 	} else if (ptable->dip_lsb_idx != 0xFF) {  //IPv4
 		pce_dasa_lsb_t dasa_tbl;
@@ -2703,7 +2787,7 @@ int pce_rule_read(void *cdev, ltq_pce_table_t *pthandle, GSW_PCE_rule_t *parm)
 			}
 
 			parm->pattern.nDstIP_Mask |= 0xFF00;
-		} else if (gswdev->gipver == LTQ_GSWIP_2_2)
+		} else if ((gswdev->gipver == LTQ_GSWIP_2_2) || (gswdev->gipver == LTQ_GSWIP_2_2_ETC))
 			parm->pattern.nDstIP_Mask = dasa_tbl.mask[0];
 	}
 
@@ -2738,7 +2822,7 @@ int pce_rule_read(void *cdev, ltq_pce_table_t *pthandle, GSW_PCE_rule_t *parm)
 							(1 << ((i * 4) + j + 16));
 				}
 			}
-		} else if (gswdev->gipver == LTQ_GSWIP_2_2)
+		} else if ((gswdev->gipver == LTQ_GSWIP_2_2) || (gswdev->gipver == LTQ_GSWIP_2_2_ETC))
 			parm->pattern.nSrcIP_Mask = dasa_tbl.mask[0] << 16;
 
 		/* SIP LS8B used */
@@ -2764,7 +2848,7 @@ int pce_rule_read(void *cdev, ltq_pce_table_t *pthandle, GSW_PCE_rule_t *parm)
 							(1 << ((i * 4) + j));
 				}
 			}
-		} else if (gswdev->gipver == LTQ_GSWIP_2_2)
+		} else if ((gswdev->gipver == LTQ_GSWIP_2_2) || (gswdev->gipver == LTQ_GSWIP_2_2_ETC))
 			parm->pattern.nSrcIP_Mask |= dasa_tbl_lsb.mask[0];
 	} else if (ptable->sip_lsb_idx != 0xFF) { //IPv4
 		pce_dasa_lsb_t dasa_tbl;
@@ -2793,7 +2877,7 @@ int pce_rule_read(void *cdev, ltq_pce_table_t *pthandle, GSW_PCE_rule_t *parm)
 			}
 
 			parm->pattern.nSrcIP_Mask |= 0xFF00;
-		} else if (gswdev->gipver == LTQ_GSWIP_2_2)
+		} else if ((gswdev->gipver == LTQ_GSWIP_2_2) || (gswdev->gipver == LTQ_GSWIP_2_2_ETC))
 			parm->pattern.nSrcIP_Mask = dasa_tbl.mask[0];
 	}
 
@@ -2815,7 +2899,7 @@ int pce_rule_read(void *cdev, ltq_pce_table_t *pthandle, GSW_PCE_rule_t *parm)
 	}
 
 	/* Protocol field table */
-	if (gswdev->gipver == LTQ_GSWIP_3_0 || IS_VRSN_31(gswdev->gipver)) {
+	if (IS_VRSN_30_31(gswdev->gipver)) {
 		if (ptable->ppp_prot_idx != 0xFF) {
 			prtcol_tbl_t   pctl_tbl;
 			memset(&pctl_tbl, 0, sizeof(prtcol_tbl_t));
@@ -2943,18 +3027,20 @@ int pce_rule_read(void *cdev, ltq_pce_table_t *pthandle, GSW_PCE_rule_t *parm)
 		}
 	}
 
-	/* OAM and Extraction flags field table */
-	if (((ptbl.val[8] >> 3) & 0x1) || ((ptbl.val[7] >> 8) & 0x1)) {
-		/*OAM flag*/
-		if ((ptbl.val[8] >> 3) & 0x1) {
-			parm->action.bOamEnable = 1;
-			/*OAM and extraction packet control*/
-			parm->action.nRecordId = ((ptbl.val[8] >> 4) & 0xFFF);
-		}
+	if (IS_VRSN_30_31(gswdev->gipver)) {
+		/* OAM and Extraction flags field table */
+		if (((ptbl.val[8] >> 3) & 0x1) || ((ptbl.val[7] >> 8) & 0x1)) {
+			/*OAM flag*/
+			if ((ptbl.val[8] >> 3) & 0x1) {
+				parm->action.bOamEnable = 1;
+				/*OAM and extraction packet control*/
+				parm->action.nRecordId = ((ptbl.val[8] >> 4) & 0xFFF);
+			}
 
-		/*Extraction flag*/
-		if ((ptbl.val[7] >> 8) & 0x1) {
-			parm->action.bExtractEnable = 1;
+			/*Extraction flag*/
+			if ((ptbl.val[7] >> 8) & 0x1) {
+				parm->action.bExtractEnable = 1;
+			}
 		}
 	}
 
@@ -2972,7 +3058,7 @@ int pce_rule_write(void *cdev, ltq_pce_table_t *pthandle, GSW_PCE_rule_t *parm)
 	int	tindex, i, reg_val = 0;
 	signed int status;
 
-	PCE_ASSERT(idx >= PCE_TABLE_SIZE);
+	PCE_ASSERT(idx >= (gswdev->tftblsize));
 
 	if (parm->pattern.bEnable == 0) {
 		/* Entry to delete. */
@@ -3022,7 +3108,7 @@ int pce_rule_write(void *cdev, ltq_pce_table_t *pthandle, GSW_PCE_rule_t *parm)
 		ptbl.key[6] |= (0x7F << 8); //Mark as don't care.
 
 	/* Pattern field - Inner DSCP value */
-	if (gswdev->gipver == LTQ_GSWIP_3_0 || IS_VRSN_31(gswdev->gipver)) {
+	if (IS_VRSN_30_31(gswdev->gipver)) {
 		if (parm->pattern.bInner_DSCP_Enable == 1)
 			ptbl.key[9] |= ((parm->pattern.nInnerDSCP & 0x3F) << 8);
 		else
@@ -3113,8 +3199,48 @@ int pce_rule_write(void *cdev, ltq_pce_table_t *pthandle, GSW_PCE_rule_t *parm)
 
 	ptbl.key[5] |= ptable->src_mac_addr_idx;
 
+	/* Pattern field - Destination Application used */
+	if (parm->pattern.bAppDataMSB_Enable == 1) {
+		app_tbl_t   appl_tbl;
+		appl_tbl.mask_range_type = parm->pattern.bAppMaskRangeMSB_Select;
+		/* Destination Application field */
+		appl_tbl.appl_data = parm->pattern.nAppDataMSB;
+		/* Destination Application mask/range */
+		appl_tbl.mask_range = parm->pattern.nAppMaskRangeMSB;
+		tindex = pce_appl_tbl_write(cdev, &pthandle->pce_sub_tbl, &appl_tbl);
+
+		if (tindex < 0)
+			return tindex;
+
+		ptable->dst_appl_fld_idx = tindex;
+	} else {
+		ptable->dst_appl_fld_idx = 0xFF; //Mark as don't care.
+	}
+
+	ptbl.key[4] |= ptable->dst_appl_fld_idx;
+
+	/* Pattern field - Source Application field used */
+	if (parm->pattern.bAppDataLSB_Enable == 1) {
+		app_tbl_t   appl_tbl;
+		appl_tbl.mask_range_type = parm->pattern.bAppMaskRangeLSB_Select;
+		/* Source Application field */
+		appl_tbl.appl_data = parm->pattern.nAppDataLSB;
+		/* Source Application mask/range */
+		appl_tbl.mask_range = parm->pattern.nAppMaskRangeLSB;
+		tindex = pce_appl_tbl_write(cdev, &pthandle->pce_sub_tbl, &appl_tbl);
+
+		if (tindex < 0)
+			return tindex;
+
+		ptable->src_appl_fld_idx = tindex;
+	} else {
+		ptable->src_appl_fld_idx = 0xFF; //Mark as don't care.
+	}
+
+	ptbl.key[4] |= (ptable->src_appl_fld_idx << 8);
+
 	/* Pattern field - Parser Flags field table */
-	if (gswdev->gipver == LTQ_GSWIP_3_0 || IS_VRSN_31(gswdev->gipver)) {
+	if (IS_VRSN_30_31(gswdev->gipver)) {
 		/* Parser flags 15:0 */
 		if (parm->pattern.bParserFlagLSB_Enable == 1) {
 			flag_tbl_t   flags_tbl;
@@ -3245,46 +3371,6 @@ int pce_rule_write(void *cdev, ltq_pce_table_t *pthandle, GSW_PCE_rule_t *parm)
 		ptbl.key[13] |= (ptable->payload2_idx << 8);
 	}
 
-	/* Pattern field - Destination Application used */
-	if (parm->pattern.bAppDataMSB_Enable == 1) {
-		app_tbl_t   appl_tbl;
-		appl_tbl.mask_range_type = parm->pattern.bAppMaskRangeMSB_Select;
-		/* Destination Application field */
-		appl_tbl.appl_data = parm->pattern.nAppDataMSB;
-		/* Destination Application mask/range */
-		appl_tbl.mask_range = parm->pattern.nAppMaskRangeMSB;
-		tindex = pce_appl_tbl_write(cdev, &pthandle->pce_sub_tbl, &appl_tbl);
-
-		if (tindex < 0)
-			return tindex;
-
-		ptable->dst_appl_fld_idx = tindex;
-	} else {
-		ptable->dst_appl_fld_idx = 0xFF; //Mark as don't care.
-	}
-
-	ptbl.key[4] |= ptable->dst_appl_fld_idx;
-
-	/* Pattern field - Source Application field used */
-	if (parm->pattern.bAppDataLSB_Enable == 1) {
-		app_tbl_t   appl_tbl;
-		appl_tbl.mask_range_type = parm->pattern.bAppMaskRangeLSB_Select;
-		/* Source Application field */
-		appl_tbl.appl_data = parm->pattern.nAppDataLSB;
-		/* Source Application mask/range */
-		appl_tbl.mask_range = parm->pattern.nAppMaskRangeLSB;
-		tindex = pce_appl_tbl_write(cdev, &pthandle->pce_sub_tbl, &appl_tbl);
-
-		if (tindex < 0)
-			return tindex;
-
-		ptable->src_appl_fld_idx = tindex;
-	} else {
-		ptable->src_appl_fld_idx = 0xFF; //Mark as don't care.
-	}
-
-	ptbl.key[4] |= (ptable->src_appl_fld_idx << 8);
-
 	/* Pattern field - outer DIP field table */
 	ptable->dip_msb_idx = 0xFF; //Mark as don't care.
 	ptable->dip_lsb_idx = 0xFF; //Mark as don't care.
@@ -3304,7 +3390,7 @@ int pce_rule_write(void *cdev, ltq_pce_table_t *pthandle, GSW_PCE_rule_t *parm)
 			mtbl.imsb[j] = ((parm->pattern.nDstIP.nIPv6[i] >> 8) & 0xFF);
 		}
 
-		if (gswdev->gipver == LTQ_GSWIP_3_0 || IS_VRSN_31(gswdev->gipver)) {
+		if (IS_VRSN_30_31(gswdev->gipver)) {
 			//mtbl.nmask = (u16)((parm->pattern.nDstIP_Mask >> 16) & 0xFFFF);
 			for (i = 0; i < 4; i++) {
 				maskNibble = ((parm->pattern.nDstIP_Mask >> ((i * 4) + 16)) & 0xF);
@@ -3336,7 +3422,7 @@ int pce_rule_write(void *cdev, ltq_pce_table_t *pthandle, GSW_PCE_rule_t *parm)
 			ltbl.ilsb[j] = ((parm->pattern.nDstIP.nIPv6[i + 4] >> 8) & 0xFF);
 		}
 
-		if (gswdev->gipver == LTQ_GSWIP_3_0 || IS_VRSN_31(gswdev->gipver)) {
+		if (IS_VRSN_30_31(gswdev->gipver)) {
 			//ltbl.nmask = (u16)(parm->pattern.nDstIP_Mask & 0xFFFF);
 			for (i = 0; i < 4; i++) {
 				maskNibble = ((parm->pattern.nDstIP_Mask >> (i * 4)) & 0xF);
@@ -3369,7 +3455,7 @@ int pce_rule_write(void *cdev, ltq_pce_table_t *pthandle, GSW_PCE_rule_t *parm)
 		for (i = 0; i < 4; i++)
 			ltbl.ilsb[i] = ((parm->pattern.nDstIP.nIPv4 >> (i * 8)) & 0xFF);
 
-		if (gswdev->gipver == LTQ_GSWIP_3_0 || IS_VRSN_31(gswdev->gipver)) {
+		if (IS_VRSN_30_31(gswdev->gipver)) {
 			int j;
 			u16 maskNibble;
 
@@ -3425,7 +3511,7 @@ int pce_rule_write(void *cdev, ltq_pce_table_t *pthandle, GSW_PCE_rule_t *parm)
 			mtbl.imsb[j]	= ((parm->pattern.nSrcIP.nIPv6[i] >> 8) & 0xFF);
 		}
 
-		if (gswdev->gipver == LTQ_GSWIP_3_0 || IS_VRSN_31(gswdev->gipver)) {
+		if (IS_VRSN_30_31(gswdev->gipver)) {
 			//mtbl.nmask = (u16)((parm->pattern.nSrcIP_Mask >> 16) & 0xFFFF);
 			for (i = 0; i < 4; i++) {
 				maskNibble = ((parm->pattern.nSrcIP_Mask >> ((i * 4) + 16)) & 0xF);
@@ -3457,7 +3543,7 @@ int pce_rule_write(void *cdev, ltq_pce_table_t *pthandle, GSW_PCE_rule_t *parm)
 			ltbl.ilsb[j] = ((parm->pattern.nSrcIP.nIPv6[i + 4] >> 8) & 0xFF);
 		}
 
-		if (gswdev->gipver == LTQ_GSWIP_3_0 || IS_VRSN_31(gswdev->gipver)) {
+		if (IS_VRSN_30_31(gswdev->gipver)) {
 			//ltbl.nmask = (u16)(parm->pattern.nSrcIP_Mask & 0xFFFF);
 			for (i = 0; i < 4; i++) {
 				maskNibble = ((parm->pattern.nSrcIP_Mask >> (i * 4)) & 0xF);
@@ -3491,7 +3577,7 @@ int pce_rule_write(void *cdev, ltq_pce_table_t *pthandle, GSW_PCE_rule_t *parm)
 		for (i = 0; i < 4; i++)
 			ltbl.ilsb[i] = ((parm->pattern.nSrcIP.nIPv4 >> (i * 8)) & 0xFF);
 
-		if (gswdev->gipver == LTQ_GSWIP_3_0 || IS_VRSN_31(gswdev->gipver)) {
+		if (IS_VRSN_30_31(gswdev->gipver)) {
 			int j;
 			u16 maskNibble;
 
@@ -3528,7 +3614,7 @@ int pce_rule_write(void *cdev, ltq_pce_table_t *pthandle, GSW_PCE_rule_t *parm)
 	ptbl.key[2] |= ptable->sip_lsb_idx;
 
 	/* Pattern field - inner DIP field table */
-	if (gswdev->gipver == LTQ_GSWIP_3_0 || IS_VRSN_31(gswdev->gipver)) {
+	if (IS_VRSN_30_31(gswdev->gipver)) {
 		ptable->inr_dip_msb_idx = 0xFF; //Mark as don't care.
 		ptable->inr_dip_lsb_idx = 0xFF; //Mark as don't care.
 
@@ -3770,7 +3856,7 @@ int pce_rule_write(void *cdev, ltq_pce_table_t *pthandle, GSW_PCE_rule_t *parm)
 	ptbl.key[1] |= ptable->ethertype_idx;
 
 	/* Pattern field - PPP Protocol table */
-	if (gswdev->gipver == LTQ_GSWIP_3_0 || IS_VRSN_31(gswdev->gipver)) {
+	if (IS_VRSN_30_31(gswdev->gipver)) {
 		if (parm->pattern.bPPP_ProtocolEnable == 1) {
 			prtcol_tbl_t   pctl_tbl;
 			memset(&pctl_tbl, 0, sizeof(prtcol_tbl_t));
@@ -3804,6 +3890,7 @@ int pce_rule_write(void *cdev, ltq_pce_table_t *pthandle, GSW_PCE_rule_t *parm)
 		if (tindex < 0)
 			return tindex;
 
+
 		ptable->ip_prot_idx = tindex;
 	} else if (parm->pattern.bInnerProtocolEnable == 1) {
 		/* Only inner IP protocol table */
@@ -3899,11 +3986,11 @@ int pce_rule_write(void *cdev, ltq_pce_table_t *pthandle, GSW_PCE_rule_t *parm)
 					tindex = act_vlan_id_create(cdev,
 								    parm->pattern.nSLAN_Vid, 0, 0);
 			}
-
-			ptable->svlan_idx = tindex;
-			ptbl.key[8] &= ~(0xFF << 8);
-			ptbl.key[8] |= (ptable->svlan_idx << 8);
 		}
+
+		ptable->svlan_idx = tindex;
+		ptbl.key[8] &= ~(0xFF << 8);
+		ptbl.key[8] |= (ptable->svlan_idx << 8);
 	}
 
 	/* Pattern field - VID value */
@@ -3974,7 +4061,7 @@ int pce_rule_write(void *cdev, ltq_pce_table_t *pthandle, GSW_PCE_rule_t *parm)
 	}
 
 	/* Pattern field - Exclude bits */
-	if (gswdev->gipver == LTQ_GSWIP_3_0 || IS_VRSN_31(gswdev->gipver)) {
+	if (IS_VRSN_30_31(gswdev->gipver)) {
 		if (parm->pattern.bPortId_Exclude == 1)
 			ptbl.key[14] |= (1 << 7);
 
@@ -4052,10 +4139,12 @@ int pce_rule_write(void *cdev, ltq_pce_table_t *pthandle, GSW_PCE_rule_t *parm)
 			ptbl.key[15] |= (1 << 15);
 	}
 
+
 	/* Populate 'action' parameter values */
 	paction = &(pthandle->pce_act[idx]);
 	memcpy(paction, &parm->action, sizeof(GSW_PCE_action_t));
 
+
 	/* Port forwarding action */
 	if (paction->ePortMapAction != GSW_PCE_ACTION_PORTMAP_DISABLE) {
 		if (paction->eSnoopingTypeAction == GSW_PCE_ACTION_IGMP_SNOOP_DISABLE) {
@@ -4072,7 +4161,7 @@ int pce_rule_write(void *cdev, ltq_pce_table_t *pthandle, GSW_PCE_rule_t *parm)
 
 			case GSW_PCE_ACTION_PORTMAP_CPU:
 			case GSW_PCE_ACTION_PORTMAP_ALTERNATIVE:
-				if (gswdev->gipver == LTQ_GSWIP_3_0) {
+				if (gswdev->gipver <= LTQ_GSWIP_3_0) {
 					/* CPU port-map */ //Govind - Need to test for 3.0 with MC router.
 					ptbl.val[1] = (paction->nForwardPortMap[0] & 0xFFFF);
 				}
@@ -4119,7 +4208,7 @@ int pce_rule_write(void *cdev, ltq_pce_table_t *pthandle, GSW_PCE_rule_t *parm)
 			ptbl.val[1] = 0xFFFF;
 		}
 
-		//Govind - But why do we need to do below?
+		//But why do we need to do below?
 		if (IS_VRSN_31(gswdev->gipver)) {
 			for (i = 0; i <= 7; i++)
 				ptbl.val[i + 10] = 0xFFFF;
@@ -4455,7 +4544,7 @@ int pce_rule_write(void *cdev, ltq_pce_table_t *pthandle, GSW_PCE_rule_t *parm)
 	}
 
 	/* Remarking action. */
-	if (gswdev->gipver == LTQ_GSWIP_3_0) {
+	if (gswdev->gipver <= LTQ_GSWIP_3_0) {
 		ptbl.val[3] |= (0x7 << 12);
 
 		if (paction->bRemarkDSCP == 1)
@@ -4514,7 +4603,7 @@ int pce_rule_write(void *cdev, ltq_pce_table_t *pthandle, GSW_PCE_rule_t *parm)
 		ptbl.val[5] |= (1 << 1);
 
 	/* IGMP snoop control */
-	if (gswdev->gipver == LTQ_GSWIP_3_0 || IS_VRSN_31(gswdev->gipver)) {
+	if (IS_VRSN_30_31(gswdev->gipver)) {
 		if (paction->ePortFilterType_Action !=
 		    GSW_PCE_PORT_FILTER_ACTION_UNUSED) {
 			if (paction->ePortMapAction == GSW_PCE_ACTION_PORTMAP_DISABLE) {
@@ -4646,6 +4735,7 @@ int pce_rule_write(void *cdev, ltq_pce_table_t *pthandle, GSW_PCE_rule_t *parm)
 		}
 	}
 
+
 	ptbl.pcindex = idx;
 	ptbl.table = PCE_TFLOW_INDEX;
 	ptbl.valid = 1;
diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_init.c b/drivers/net/ethernet/lantiq/switch-api/gsw_init.c
index 46b07866b13d..ecb17c8a0f83 100644
--- a/drivers/net/ethernet/lantiq/switch-api/gsw_init.c
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_init.c
@@ -415,13 +415,12 @@ void gsw_r32_raw(void *cdev, short offset, u32 *value)
 		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
 		return;
 	}
-	
+
 	if (pethdev->gsw_base != 0) {
 		*value = gsw1_r32((volatile void *)pethdev->gsw_base + (offset * 4));
-	}
-	else {
+	} else {
 		/*external switch*/
-		gsw_ext_r32(cdev,offset,0,16,value);
+		gsw_ext_r32(cdev, offset, 0, 16, value);
 	}
 
 }
@@ -439,14 +438,14 @@ void gsw_w32_raw(void *cdev, short offset, u32 value)
 		gsw1_w32(value, (volatile void *)(pethdev->gsw_base + (offset * 4)));
 	} else {
 		/*external switch*/
-		gsw_ext_w32(cdev,offset,0,16,value);
+		gsw_ext_w32(cdev, offset, 0, 16, value);
 	}
 }
 
 
 int GSW_SMDIO_DataRead(void *cdev, GSW_MDIO_data_t *pPar)
 {
-	int ret=0;
+	int ret = 0;
 	ethsw_api_dev_t *pethdev = GSW_PDATA_GET(cdev);
 
 #ifdef CONFIG_X86_INTEL_CE2700
@@ -456,8 +455,8 @@ int GSW_SMDIO_DataRead(void *cdev, GSW_MDIO_data_t *pPar)
 	pPar->nData = data & 0xFFFF;
 #else
 	struct core_ops *gsw_ops;
-	gsw_ops=gsw_get_swcore_ops(pethdev->parent_devid);
-	gsw_ops->gsw_common_ops.MDIO_DataRead(gsw_ops,pPar);
+	gsw_ops = gsw_get_swcore_ops(pethdev->parent_devid);
+	gsw_ops->gsw_common_ops.MDIO_DataRead(gsw_ops, pPar);
 
 #endif
 	return ret;
@@ -465,16 +464,16 @@ int GSW_SMDIO_DataRead(void *cdev, GSW_MDIO_data_t *pPar)
 
 int GSW_SMDIO_DataWrite(void *cdev, GSW_MDIO_data_t *pPar)
 {
-	int ret=0;
+	int ret = 0;
 	ethsw_api_dev_t *pethdev = GSW_PDATA_GET(cdev);
 
 #ifdef CONFIG_X86_INTEL_CE2700
 	ret = DWC_ETH_QOS_mdio_write_direct(MDIO_BUS_NUMBER_0, C45_ENABLED,
-					     MDIO_ADDR_LANTIQ, MMD_DISABLED, pPar->nAddressReg & 0x1F, pPar->nData & 0xFFFF);
+					    MDIO_ADDR_LANTIQ, MMD_DISABLED, pPar->nAddressReg & 0x1F, pPar->nData & 0xFFFF);
 #else
 	struct core_ops *gsw_ops;
-	gsw_ops=gsw_get_swcore_ops(pethdev->parent_devid);
-	gsw_ops->gsw_common_ops.MDIO_DataWrite(gsw_ops,pPar);
+	gsw_ops = gsw_get_swcore_ops(pethdev->parent_devid);
+	gsw_ops->gsw_common_ops.MDIO_DataWrite(gsw_ops, pPar);
 #endif
 
 	return ret;
@@ -510,7 +509,7 @@ void gsw_ext_r32(void *cdev, short offset, short shift, short size, u32 *value)
 	mask = (1 << size) - 1;
 	rvalue = (rvalue >> shift);
 	*value = (rvalue & mask);
-	
+
 }
 
 /** read and update the GSWIP register */
@@ -614,15 +613,15 @@ void gsw_r32(void *cdev, short offset, short shift, short size, u32 *value)
 	} else {
 
 #ifdef __KERNEL__
-	/*external switch*/
-		if(pethdev->ext_devid) {
-			gsw_ext_r32(cdev,offset,shift,size,value);
-		}
-		else
+
+		/*external switch*/
+		if (pethdev->ext_devid) {
+			gsw_ext_r32(cdev, offset, shift, size, value);
+		} else
 #endif
 			pr_err("%s:%s:%d,(ERROR)\n", __FILE__, __func__, __LINE__);
 	}
-	
+
 }
 
 /** read and update the GSWIP register */
@@ -658,9 +657,10 @@ void gsw_w32(void *cdev, short offset, short shift, short size, u32 value)
 	} else {
 
 #ifdef __KERNEL__
+
 		/*external switch*/
-		if(pethdev->ext_devid)
-			gsw_ext_w32(cdev,offset,shift,size,value);
+		if (pethdev->ext_devid)
+			gsw_ext_w32(cdev, offset, shift, size, value);
 		else
 #endif
 			pr_err("%s:%s:%d,(ERROR)\n", __FILE__, __func__, __LINE__);
@@ -998,7 +998,7 @@ int ltq_gsw_api_register(struct platform_device *pdev)
 	}
 
 	if (device_id == 1) {
-		ethsw_api_dev_t *PrvData,*ExtPrvData;
+		ethsw_api_dev_t *PrvData, *ExtPrvData;
 		struct core_ops *ops;
 
 		/* Init FLOW Switch Core Layer */
@@ -1024,33 +1024,36 @@ int ltq_gsw_api_register(struct platform_device *pdev)
 		/** Get Switch Core Private Data */
 		PrvData = container_of(ops, ethsw_api_dev_t, ops);
 
-		if(PrvData->ext_devid == LTQ_FLOW_DEV_EXT_AX3000_F24S) {
+		if (PrvData->ext_devid == LTQ_FLOW_DEV_EXT_AX3000_F24S) {
 			ethsw_core_init_t ext_core_init;
-			
+
 			/** Clear core_init */
 			memset(&ext_core_init, 0, sizeof(ethsw_core_init_t));
 
-#if 0
-			/*hardcoded temp setting to power on F24s
-			  Note : will be removed when check in ugw 8*/
+#if defined(DEBUG_AX3000_F24S) && DEBUG_AX3000_F24S
+			/*hardcoded temp setting to power on F24s AX3000 model
+			  Note :Only for debugging purpose, macro is disabled
+			  when check in to ugw 8.x*/
 			gsw1_w32(0x800,	(volatile void *)0xb6080120);
 			gsw1_w32(0x7c,	(volatile void *)0xbc003c1c);
-			gsw1_w32(0x180,	(volatile void *)0xba003d10);
-			gsw1_w32(0x100800,  (volatile void *)0xb6080120);
-			gsw1_w32(0x80000000,  (volatile void *)0xb6000010);
-			gsw1_w32(0x0,  (volatile void *)0xb6000010);
-			gsw1_w32(0xff,  (volatile void *)0xb6D00034);
-			gsw1_w32(0xff,  (volatile void *)0xb6D00044);
-			gsw1_w32(0x00008800,  (volatile void *)0xb6D002B8);
+			gsw1_w32(0x1806,	(volatile void *)0xba003d10);
+			gsw1_w32(0x100800, (volatile void *)0xb6080120);
+			gsw1_w32(0x80000000, (volatile void *)0xb6000010);
+			gsw1_w32(0x0, (volatile void *)0xb6000010);
+			gsw1_w32(0xff, (volatile void *)0xb6D00034);
+			gsw1_w32(0xff, (volatile void *)0xb6D00044);
+			gsw1_w32(0x00008800, (volatile void *)0xb6D002B8);
 #endif
 			ExtPrvData = (void *)kmalloc(sizeof(ethsw_api_dev_t), GFP_KERNEL);
-			if (ExtPrvData== NULL) {
+
+			if (ExtPrvData == NULL) {
 				pr_err("%s:%s:%d (Exterenal switch:LTQ_FLOW_DEV_EXT_AX3000_F24S Init Failed)\n",
-			       __FILE__, __func__, __LINE__);
+				       __FILE__, __func__, __LINE__);
 				return -1;
 			}
+
 			memset(ExtPrvData, 0, sizeof(ethsw_api_dev_t));
-			
+
 			/*init external switch private data*/
 			ExtPrvData->cport = GSW_2X_SOC_CPU_PORT;
 			ExtPrvData->gsw_dev = LTQ_FLOW_DEV_EXT_AX3000_F24S;
@@ -1059,22 +1062,23 @@ int ltq_gsw_api_register(struct platform_device *pdev)
 			ExtPrvData->ext_phyid = PrvData->ext_phyid;
 			ExtPrvData->gswex_base = PrvData->gswex_base;
 			ExtPrvData->gswex_sgmiibase = PrvData->gswex_sgmiibase;
-			
+
 			/* Init External Switch Core Layer */
 			ext_core_init.sdev = LTQ_FLOW_DEV_EXT_AX3000_F24S;
 			ext_core_init.gsw_base_addr = NULL;
 			ext_core_init.pdev = (void *)ExtPrvData;
 			pEDevExt = ethsw_api_core_init(&ext_core_init);
+
 			if (pEDevExt == NULL) {
 				pr_err("%s:%s:%d (Init Failed)\n",
 				       __FILE__, __func__, __LINE__);
 				return -1;
 			}
-			
+
 		}
 
 	}
-	
+
 
 	if (device_id == 0) {
 		ioct_cmd_start_node = gsw_create_ioctl_cmd_linklist(&pEDev0->ops);
@@ -1096,13 +1100,14 @@ int ltq_gsw_api_register(struct platform_device *pdev)
 	/* add Internal switch */
 	if ((device_id == 1) && pioctlctl && pEDev1) {
 		ioctl_wrapper_dev_add(pioctlctl, &pEDev1->ops, LTQ_FLOW_DEV_INT_R);
-		
+
 		/* Init wrapper , if external switch attached to GSWIP-R*/
 		if ((pEDev1->ext_devid == LTQ_FLOW_DEV_EXT_AX3000_F24S) && pioctlctl && pEDevExt) {
 			ioctl_wrapper_dev_add(pioctlctl, &pEDevExt->ops, LTQ_FLOW_DEV_EXT_AX3000_F24S);
 		}
 
 	}
+
 	return 0;
 }
 #endif /* CONFIG_SOC_GRX500 */
diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_init.h b/drivers/net/ethernet/lantiq/switch-api/gsw_init.h
index fb244459a61b..decdd90eed40 100644
--- a/drivers/net/ethernet/lantiq/switch-api/gsw_init.h
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_init.h
@@ -24,6 +24,7 @@
 #define CONFIG_LTQ_PMAC		1
 #define CONFIG_LTQ_RMON		1
 
+#define DEBUG_AX3000_F24S		0
 
 #define CONFIG_MAC  1
 
diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_tbl_rw.c b/drivers/net/ethernet/lantiq/switch-api/gsw_tbl_rw.c
index da016c508d23..ee24cc9363d1 100644
--- a/drivers/net/ethernet/lantiq/switch-api/gsw_tbl_rw.c
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_tbl_rw.c
@@ -489,6 +489,7 @@ int gsw_pce_table_write(void *cdev, pctbl_prog_t *ptdata)
 	/*KEY REG*/
 	j = gswdev->pce_tbl_info[ptdata->table].num_key;
 
+
 	if (ptdata->kformat)
 		j *= 4;
 
@@ -508,8 +509,6 @@ int gsw_pce_table_write(void *cdev, pctbl_prog_t *ptdata)
 
 	for (i = 0; i < j; i++) {
 		gsw_w32_raw(cdev, gswdev->pce_tbl_reg.value[i], ptdata->val[i]);
-//		printk("gswdev->pce_tbl_reg.value[%d] =%x\n", i, gswdev->pce_tbl_reg.value[i]);
-//		printk("ptdata->val[%d] =%x\n", i, ptdata->val[i]);
 	}
 
 	ctrlval = gsw_field_w32(ctrlval, PCE_TBL_CTRL_KEYFORM_SHIFT,
