From 660f0911ee8f4a560fd49b82f48af74b1c2d24dd Mon Sep 17 00:00:00 2001
From: CI Assistant <yossi.ilkanaev@intel.com>
Date: Fri, 14 Sep 2018 06:36:01 +0200
Subject: [PATCH] Merge pull request #140 in SW_UGW/linux from
 feature/DRVLIB_SW-853-ctp-to-traffic-class-map to master

* commit 'bb5fceecfa3e59fad503c9f7418e66492fb34fdd':
  DRVLIB_SW-853: CTP_TC kernel flag review comments fix
  DRVLIB_SW-853: CTP_TC proc review comments fix
  DRVLIB_SW-853: dp metering API implementation fixes
  DRVLIB_SW-853: ctp_tc review comments addressed
  DRVLIB_SW-853: dp metering API fixes for pull request review comments fixes
  DRVLIB_SW-853 Export get bridge FID API
  DRVLIB_SW-853: dp metering API fixes after review comments and merge
  DRVLIB_SW-853: DP export ctp_tc api and return 'inst' for bridge device
  DRVLIB_SW-853: dp metering API implementation and checkpatch fixes
  DRVLIB_SW-853:  switch api change to configure all traffic class
  DRVLIB_SW-853:  swdev new api to get FID from brname
  DRVLIB_SW-853: CTP traffic class setting
---
 .../net/ethernet/lantiq/datapath/datapath_api.c    |   4 +
 .../ethernet/lantiq/datapath/datapath_instance.c   |   3 +-
 .../net/ethernet/lantiq/datapath/datapath_ioctl.h  |   2 +-
 .../net/ethernet/lantiq/datapath/datapath_misc.c   | 103 +++++
 .../ethernet/lantiq/datapath/datapath_notifier.c   |   2 +-
 .../net/ethernet/lantiq/datapath/datapath_proc.c   | 155 +++++++
 .../ethernet/lantiq/datapath/datapath_proc_qos.c   |   1 -
 .../net/ethernet/lantiq/datapath/datapath_swdev.c  | 114 ++---
 .../net/ethernet/lantiq/datapath/datapath_swdev.h  |   2 +-
 .../lantiq/datapath/gswip31/datapath_gswip.c       | 470 ++++++++++++++++++++-
 .../lantiq/datapath/gswip31/datapath_misc.c        |  50 +++
 .../lantiq/datapath/gswip31/datapath_misc.h        |   7 +
 .../lantiq/datapath/gswip31/datapath_proc.c        |  39 +-
 .../net/ethernet/lantiq/switch-api/gsw_defconf.c   |   2 +-
 include/net/datapath_api.h                         |  11 +
 include/net/datapath_api_qos.h                     |   6 +-
 include/net/datapath_inst.h                        |  18 +-
 17 files changed, 904 insertions(+), 85 deletions(-)

diff --git a/drivers/net/ethernet/lantiq/datapath/datapath_api.c b/drivers/net/ethernet/lantiq/datapath/datapath_api.c
index 0ce8fa21f935..2872bfa819d2 100644
--- a/drivers/net/ethernet/lantiq/datapath/datapath_api.c
+++ b/drivers/net/ethernet/lantiq/datapath/datapath_api.c
@@ -1093,6 +1093,7 @@ int32_t dp_get_netif_subifid(struct net_device *netif, struct sk_buff *skb,
 		end = start + 1;
 	}
 #endif
+	subif->flag_pmapper = 0;
 	DP_LIB_LOCK(&dp_lock);
 	for (k = start; k < end; k++) {
 		if (dp_port_info[inst][k].status != PORT_SUBIF_REGISTERED)
@@ -1153,6 +1154,9 @@ int32_t dp_get_netif_subifid(struct net_device *netif, struct sk_buff *skb,
 								 subif);
 					subif_flag[num] = PORT_SUBIF(inst, k, i,
 								subif_flag);
+					if (dp_port_info[inst][k].subif_info[i].
+						ctp_dev)
+						subif->flag_pmapper = 1;
 					bport = PORT_SUBIF(inst, k, i, bp);
 					if (num &&
 					    (bport != dp_port_info[inst][k].
diff --git a/drivers/net/ethernet/lantiq/datapath/datapath_instance.c b/drivers/net/ethernet/lantiq/datapath/datapath_instance.c
index f320c3370cbc..c942287e8e71 100644
--- a/drivers/net/ethernet/lantiq/datapath/datapath_instance.c
+++ b/drivers/net/ethernet/lantiq/datapath/datapath_instance.c
@@ -247,7 +247,6 @@ int dp_inst_add_dev(struct net_device *dev, char *subif_name, int inst,
 			dp_dev->count = 0;
 			dp_dev->subif_name[0] = 0;
 			dp_dev->fid = 0;
-			//dp_port_info[inst][0].subif_info[0].fid = dp_dev->fid;
 			INIT_LIST_HEAD(&dp_dev->ctp_list);
 			new_f = 1;
 		}
@@ -278,7 +277,7 @@ int dp_inst_add_dev(struct net_device *dev, char *subif_name, int inst,
 					 sizeof(*dev->netdev_ops),
 					 (void **)&dp_dev->old_dev_ops,
 					 &dp_dev->new_dev_ops,
-					 (unsigned long)&dp_ndo_setup_tc);
+					 &dp_ndo_setup_tc);
 			if (err)
 				return DP_FAILURE;
 		}
diff --git a/drivers/net/ethernet/lantiq/datapath/datapath_ioctl.h b/drivers/net/ethernet/lantiq/datapath/datapath_ioctl.h
index 14fa2165769d..436e378b4723 100644
--- a/drivers/net/ethernet/lantiq/datapath/datapath_ioctl.h
+++ b/drivers/net/ethernet/lantiq/datapath/datapath_ioctl.h
@@ -14,7 +14,7 @@ int dp_ops_reset(struct dp_dev *dp_dev,
 		 struct net_device *dev);
 int dp_ops_set(void **dev_ops, int ops_cb_offset,
 	       size_t ops_size, void **dp_orig_ops_cb,
-		   void *dp_new_ops, void *new_ops_cb);
+	       void *dp_new_ops, void *new_ops_cb);
 
 #endif
 /*DATAPATH_IOCTL_H*/
diff --git a/drivers/net/ethernet/lantiq/datapath/datapath_misc.c b/drivers/net/ethernet/lantiq/datapath/datapath_misc.c
index d5a328c9a305..45af7a6c3231 100644
--- a/drivers/net/ethernet/lantiq/datapath/datapath_misc.c
+++ b/drivers/net/ethernet/lantiq/datapath/datapath_misc.c
@@ -1121,3 +1121,106 @@ int print_symbol_name(unsigned long addr)
 	return 0;
 }
 
+int dp_ctp_tc_map_set(struct dp_tc_cfg *tc, int flag)
+
+{
+	struct dp_meter_subif mtr_subif = {0};
+
+	if (dp_get_netif_subifid(tc->dev, NULL, NULL, NULL,
+				 &mtr_subif.subif, 0)) {
+		DP_DEBUG(DP_DBG_FLAG_DBG, "get subifid fail(%s)\n",
+			 tc->dev ? tc->dev->name : "NULL");
+		return DP_FAILURE;
+	}
+	mtr_subif.inst =  mtr_subif.subif.inst;
+	if (!dp_port_prop[mtr_subif.inst].info.dp_ctp_tc_map_set)
+		return DP_FAILURE;
+	return dp_port_prop[mtr_subif.inst].info.
+		dp_ctp_tc_map_set(tc, flag, &mtr_subif);
+}
+EXPORT_SYMBOL(dp_ctp_tc_map_set);
+
+int dp_meter_alloc(int inst, int *meterid, int flag)
+{
+	if (!dp_port_prop[inst].info.dp_meter_alloc)
+		return DP_FAILURE;
+	return dp_port_prop[inst].info.dp_meter_alloc(inst,
+						      meterid, flag);
+}
+EXPORT_SYMBOL(dp_meter_alloc);
+
+int dp_meter_add(struct net_device *dev, struct dp_meter_cfg *meter,
+		 int flag)
+{
+	struct dp_meter_subif mtr_subif = {0};
+
+	if ((flag & DP_METER_ATTACH_CTP) ||
+	    (flag & DP_METER_ATTACH_BRPORT) ||
+	    (flag & DP_METER_ATTACH_PCE)) {
+		if (dp_get_netif_subifid(dev, NULL, NULL,
+		    NULL, &mtr_subif.subif, 0)) {
+			DP_DEBUG(DP_DBG_FLAG_DBG,
+			"get subifid fail:%s\n",
+			dev ? dev->name : "NULL");
+			return DP_FAILURE;
+		}
+		mtr_subif.inst =  mtr_subif.subif.inst;
+	} else if (flag & DP_METER_ATTACH_BRIDGE) {
+		mtr_subif.fid = dp_get_fid_by_brname(dev, &mtr_subif.inst);
+		if (mtr_subif.fid < 0) {
+			PR_ERR("fid less then 0\n");
+			return DP_FAILURE;
+		}
+	} else {
+		PR_ERR("Meter Flag not set\n");
+		return DP_FAILURE;
+	}
+
+	if (!dp_port_prop[mtr_subif.inst].info.dp_meter_add)
+		return DP_FAILURE;
+	return dp_port_prop[mtr_subif.inst].info.dp_meter_add(dev, meter,
+						    flag, &mtr_subif);
+}
+EXPORT_SYMBOL(dp_meter_add);
+
+int dp_meter_del(struct net_device *dev, struct dp_meter_cfg *meter,
+		 int flag)
+{
+	struct dp_meter_subif mtr_subif = {0};
+
+	if ((flag & DP_METER_ATTACH_CTP) ||
+	    (flag & DP_METER_ATTACH_BRPORT) ||
+	    (flag & DP_METER_ATTACH_PCE)) {
+		if (dp_get_netif_subifid(dev, NULL, NULL,
+		    NULL, &mtr_subif.subif, 0)) {
+			DP_DEBUG(DP_DBG_FLAG_DBG,
+			"get subifid fail:%s\n",
+			dev ? dev->name : "NULL");
+			return DP_FAILURE;
+		}
+		mtr_subif.inst = mtr_subif.subif.inst;
+	} else if (flag & DP_METER_ATTACH_BRIDGE) {
+		mtr_subif.fid = dp_get_fid_by_brname(dev, &mtr_subif.inst);
+		if (mtr_subif.fid < 0) {
+			PR_ERR("fid less then 0\n");
+			return DP_FAILURE;
+		}
+	} else {
+		PR_ERR("Meter Flag not set\n");
+		return DP_FAILURE;
+	}
+
+	if (!dp_port_prop[mtr_subif.inst].info.dp_meter_del)
+		return DP_FAILURE;
+	return dp_port_prop[mtr_subif.inst].info.dp_meter_del(dev, meter,
+						    flag, &mtr_subif);
+}
+EXPORT_SYMBOL(dp_meter_del);
+
+#if (!IS_ENABLED(CONFIG_LTQ_DATAPATH_SWITCHDEV))
+int dp_get_fid_by_brname(struct net_device *dev, int *inst)
+{
+	PR_ERR("API not support when SWDEV disabled\n");
+	return -1;
+}
+#endif
diff --git a/drivers/net/ethernet/lantiq/datapath/datapath_notifier.c b/drivers/net/ethernet/lantiq/datapath/datapath_notifier.c
index 956f04fa00e0..c706b8b074a5 100644
--- a/drivers/net/ethernet/lantiq/datapath/datapath_notifier.c
+++ b/drivers/net/ethernet/lantiq/datapath/datapath_notifier.c
@@ -123,7 +123,7 @@ int dp_event(struct notifier_block *this, unsigned long event, void *ptr)
 		 */
 		DP_DEBUG(DP_DBG_FLAG_NOTIFY, "Bridge name:%s\n",
 			 br_dev ? br_dev->name : "NULL");
-		br_info = dp_swdev_bridge_entry_lookup(br_dev->name, 0);
+		br_info = dp_swdev_bridge_entry_lookup(br_dev->name);
 		if (br_info) {
 			dp_dev->fid = br_info->fid;
 		} else {
diff --git a/drivers/net/ethernet/lantiq/datapath/datapath_proc.c b/drivers/net/ethernet/lantiq/datapath/datapath_proc.c
index 5dc54c28dc97..ab5c78f6db48 100644
--- a/drivers/net/ethernet/lantiq/datapath/datapath_proc.c
+++ b/drivers/net/ethernet/lantiq/datapath/datapath_proc.c
@@ -22,6 +22,12 @@
 #include "datapath.h"
 #include "datapath_instance.h"
 
+/*meter alloc,add macros*/
+#define DP_METER_ALLOC(inst, id, flag) \
+	dp_port_prop[(inst)].info.dp_meter_alloc(inst, &(id), (flag))
+#define DP_METER_CFGAPI(inst, func, dev, meter, flag, mtr_subif) \
+	dp_port_prop[(inst)].info.func((dev), &(meter), (flag), (mtr_subif))
+
 #define DP_PROC_NAME       "dp"
 #define DP_PROC_BASE       "/proc/" DP_PROC_NAME "/"
 #define DP_PROC_PARENT     ""
@@ -39,6 +45,7 @@
 #define PROC_TX_PKT "tx"
 #define PROC_QOS  "qos"
 #define PROC_ASYM_VLAN  "asym_vlan"
+#define PROC_METER "meter"
 
 static int tmp_inst;
 static ssize_t proc_port_write(struct file *file, const char *buf,
@@ -55,6 +62,9 @@ static ssize_t proc_dt_write(struct file *file, const char *buf,
 			     size_t count, loff_t *ppos);
 static ssize_t proc_logical_dev_write(struct file *file, const char *buf,
 				      size_t count, loff_t *ppos);
+static ssize_t proc_meter_write(struct file *file, const char *buf,
+				size_t count, loff_t *ppos);
+static void meter_create_help(void);
 static int proc_port_init(void);
 
 int proc_port_init(void)
@@ -2198,6 +2208,150 @@ ssize_t proc_tx_pkt(struct file *file, const char *buf,
 	return count;
 }
 
+void meter_create_help(void)
+{
+	PR_INFO("METER ADD/DELETE: echo meter <dev> %s",
+		"<alloc/dealloc/add/delete>\n");
+	PR_INFO("<port_flag> <trfic_dir> <trfic_type> <cir> <pir> <cbs> %s",
+		"<pbs> <type> > /sys/kernel/debug/dp/qos");
+	PR_INFO("     dev: CTP/BP/Bridge device name\n");
+	PR_INFO("     alloc/deallc/add/del: meter operation\n");
+	PR_INFO("     port_flag: opt flag for CTP/BP/br/clrMrk/CPUtrfic\n");
+	PR_INFO("     trfic_dir: opt ingress or egress data\n");
+	PR_INFO("     trfic_type: traffic flow type(unicast,multicast,..\n");
+	PR_INFO("     cir: opt committed information rate in bit/s\n");
+	PR_INFO("     pir: opt Peak information rate in bit/s\n");
+	PR_INFO("     cbs: opt committed burst size in bytes\n");
+	PR_INFO("     pbs: opt peak burst size in bytes\n");
+	PR_INFO("     type:opt type single/dual rate(strTCM,trTCM\n");
+}
+
+ssize_t proc_meter_write(struct file *file, const char *buf, size_t count,
+			 loff_t *ppos)
+{
+	int len;
+	char str[100];
+	char *param_list[16] = { 0 };
+	unsigned int level = 0, num = 0;
+
+	len = (sizeof(str) > count) ? count : sizeof(str) - 1;
+	len -= copy_from_user(str, buf, len);
+	str[len] = 0;
+
+	if (!len)
+		return count;
+
+	num = dp_split_buffer(str, param_list, ARRAY_SIZE(param_list));
+	level = num - 3;
+
+	if ((num <= 1 || num > ARRAY_SIZE(param_list)) ||
+	    (dp_strncmpi(param_list[0], "help", strlen("help")) == 0))
+		meter_create_help();
+	else if (dp_strncmpi(param_list[0], "meter",
+			     strlen("meter")) == 0) {
+		int inst = 0;
+		struct dp_meter_cfg meter = {
+			.type = srTCM,
+			.cir = 5000000,
+			.pir = 5000000,
+			.cbs = 1023,
+			.pbs = 1023,
+			.col_mode = 0,
+			.dir = DP_DIR_EGRESS,
+			.mode = DP_PCP_8P0D,
+			.dp_pce.flow = DP_UKNOWN_UNICAST,
+			.dp_pce.pce_idx = 0
+		};
+		struct net_device *dev;
+		int ret;
+		int meter_flag = DP_METER_ATTACH_CTP, meterid = -1;
+		struct dp_meter_subif mtr_subif = {0};
+		
+		mtr_subif.inst = inst;
+		dev = dev_get_by_name(&init_net, param_list[1]);
+		if (!dev) {
+			PR_ERR(" dev NULL\n");
+			return count;
+		}
+		ret = dp_get_netif_subifid(dev, NULL, NULL, NULL,
+					   &mtr_subif.subif, 0);
+		if ( ret < 0) {
+			PR_ERR("subif fails\n");
+			return count;
+		}
+		if (dp_strncmpi(param_list[2], "dealloc",
+				strlen("dealloc") + 1) == 0) {
+			meterid = dp_atoi(param_list[3]);
+			ret = DP_METER_ALLOC(inst, meterid, DP_F_DEREGISTER);
+			if (ret < 0) {
+				PR_ERR("Fail to get meter dealloc\n");
+				return count;
+			}
+		PR_INFO("Meter dealloc succes, MeterId:=%d\n",
+			meterid);
+		} else if (dp_strncmpi(param_list[2], "alloc",
+				       strlen("alloc") + 1) == 0) {
+			ret = DP_METER_ALLOC(inst, meterid, 0);
+			if (ret < 0) {
+				PR_ERR("Fail to get meter alloc\n");
+				return count;
+			}
+			PR_INFO("Meter alloc succes, MeterId:=%d\n", meterid);
+		} else if ((dp_strncmpi(param_list[2], "del",
+					strlen("del") + 1) == 0) ||
+					(dp_strncmpi(param_list[2], "add",
+					strlen("add")+ 1) == 0)) {
+			int param_val;
+
+			if (!param_list[3]) {
+				PR_ERR("meterid NULLL\n");
+				return count;
+			}
+			param_val = dp_atoi(param_list[3]);
+			if (param_val < 0) {
+				PR_ERR("meterid less then 0");
+				return count;
+			}
+			meter.meter_id = param_val;
+			if (param_list[4])
+				meter_flag = dp_atoi(param_list[4]);
+			if (param_list[5])
+				meter.dir = dp_atoi(param_list[5]);
+			if (param_list[6])
+				meter.dp_pce.flow = dp_atoi(param_list[6]);
+			if (param_list[7])
+				meter.cir = dp_atoi(param_list[7]);
+			if (param_list[8])
+				meter.pir = dp_atoi(param_list[8]);
+			if (param_list[9])
+				meter.cbs = dp_atoi(param_list[9]);
+			if (param_list[10])
+				meter.pbs = dp_atoi(param_list[10]);
+			if (param_list[11])
+				meter.type = dp_atoi(param_list[11]);
+			meter.mode = DP_PCP_8P0D;
+			if (dp_strncmpi(param_list[2], "add",
+					strlen("add")) == 0)
+				ret = DP_METER_CFGAPI(inst, dp_meter_add, dev,
+						      meter, meter_flag, &mtr_subif);
+			else
+				ret = DP_METER_CFGAPI(inst, dp_meter_del, dev,
+						      meter, meter_flag, &mtr_subif);
+			if (ret < 0) {
+				PR_ERR("meter %s failed\n",
+				       param_list[2]);
+				return count;
+			}
+			PR_INFO("meterid:=%d %s success\n",
+				meter.meter_id, param_list[2]);
+		}
+	} else {
+		PR_INFO("Wrong Paramters\n");
+		meter_create_help();
+	}
+	return count;
+}
+
 static struct dp_proc_entry dp_proc_entries[] = {
 	/*name single_callback_t multi_callback_t/_start write_callback_t */
 #if defined(CONFIG_LTQ_DATAPATH_DBG) && CONFIG_LTQ_DATAPATH_DBG
@@ -2214,6 +2368,7 @@ static struct dp_proc_entry dp_proc_entries[] = {
 	{PROC_TX_PKT, NULL, NULL, NULL, proc_tx_pkt},
 	{PROC_QOS, NULL, qos_dump, qos_dump_start, proc_qos_write},
 	{PROC_ASYM_VLAN, NULL, NULL, NULL, proc_asym_vlan},
+	{PROC_METER, NULL, NULL, NULL, proc_meter_write},
 
 	/*the last place holder */
 	{NULL, NULL, NULL, NULL, NULL}
diff --git a/drivers/net/ethernet/lantiq/datapath/datapath_proc_qos.c b/drivers/net/ethernet/lantiq/datapath/datapath_proc_qos.c
index 085091aa1900..77156d87254f 100644
--- a/drivers/net/ethernet/lantiq/datapath/datapath_proc_qos.c
+++ b/drivers/net/ethernet/lantiq/datapath/datapath_proc_qos.c
@@ -17,7 +17,6 @@
 #define PROC_MAX_Q_PER_PORT 16 /* max queues per port */
 #define PROC_DP_MAX_SCH_PER_PORT 4 /* max schedulers per port */
 #define PROC_DP_MAX_LEAF 8 /* max leaf per scheduler */
-
 struct location {
 	int x1, y1; /* start axis */
 	int x2, y2; /* end axis */
diff --git a/drivers/net/ethernet/lantiq/datapath/datapath_swdev.c b/drivers/net/ethernet/lantiq/datapath/datapath_swdev.c
index 95679bbc7a29..857c94fbfc79 100644
--- a/drivers/net/ethernet/lantiq/datapath/datapath_swdev.c
+++ b/drivers/net/ethernet/lantiq/datapath/datapath_swdev.c
@@ -62,24 +62,33 @@ u16 dp_swdev_cal_hash(unsigned char *name)
 	return (u16)(hash & 0x3F);
 }
 
+int dp_get_fid_by_brname(struct net_device *dev, int *inst)
+{
+	struct br_info *br_info;
+
+	br_info = dp_swdev_bridge_entry_lookup(dev->name);
+	if (!br_info) {
+		return -1;
+	} else {
+		*inst = br_info->inst;
+		return br_info->fid;
+	}
+}
+EXPORT_SYMBOL(dp_get_fid_by_brname);
+
 int dp_swdev_chk_bport_in_br(struct net_device *bp_dev, int bport, int inst)
 {
 	struct net_device *br_dev;
 	struct bridge_member_port *temp_list = NULL;
 	struct br_info *br_info;
 	int found = 0;
-	bool f_unlock = false;
 
-	if (!rtnl_is_locked()) {
-		rtnl_lock();
-		f_unlock = true;
-	}
 	br_dev = netdev_master_upper_dev_get(bp_dev);
-	if (f_unlock)
-		rtnl_unlock();
 	if (!br_dev)
 		return -1;
-	br_info = dp_swdev_bridge_entry_lookup(br_dev->name, inst);
+	br_info = dp_swdev_bridge_entry_lookup(br_dev->name);
+	if (!br_info)
+		return -1;
 	list_for_each_entry(temp_list, &br_info->bp_list, list) {
 		if (temp_list->portid == bport) {
 			found = 1;
@@ -93,23 +102,28 @@ int dp_swdev_chk_bport_in_br(struct net_device *bp_dev, int bport, int inst)
 	return -1;
 }
 
-struct br_info *dp_swdev_bridge_entry_lookup(char *br_name,
-					     int inst)
+struct br_info *dp_swdev_bridge_entry_lookup(char *br_name)
 {
 	u16 idx;
 	struct br_info *br_item = NULL;
 	struct hlist_head *tmp;
+	int i = 0;
 
 	idx = dp_swdev_cal_hash(br_name);
 	DP_DEBUG(DP_DBG_FLAG_SWDEV, "hash index:%d\n", idx);
-	tmp = (&g_bridge_id_entry_hash_table[inst][idx]);
-	hlist_for_each_entry(br_item, tmp, br_hlist) {
-		if (br_item) {
-			if (strcmp(br_name, br_item->br_device_name) == 0) {
-				DP_DEBUG(DP_DBG_FLAG_SWDEV,
-					 "hash entry found(%s)\n",
-					 br_name);
-				return br_item;
+	for (i = 0; i < DP_MAX_INST; i++) {
+		tmp = (&g_bridge_id_entry_hash_table[i][idx]);
+		hlist_for_each_entry(br_item, tmp, br_hlist) {
+			if (br_item) {
+				if (strcmp(br_name,
+					   br_item->br_device_name) == 0) {
+					DP_DEBUG(DP_DBG_FLAG_SWDEV,
+						 "hash entry found(%s)\n",
+						 br_name);
+					return br_item;
+				}
+			} else {
+				break;
 			}
 		}
 	}
@@ -230,8 +244,7 @@ static int dp_swdev_clr_gswip_cfg(struct bridge_id_entry_item *br_item,
 			 "bport not added so no action required\n");
 		return 0;
 	}
-	br_info = dp_swdev_bridge_entry_lookup(br_item->br_device_name,
-					       br_item->inst);
+	br_info = dp_swdev_bridge_entry_lookup(br_item->br_device_name);
 	if (!br_info)
 		return 0;
 	if (dp_swdev_del_bport_from_list(br_info, br_item->portid)) {
@@ -262,11 +275,6 @@ static int dp_swdev_cfg_vlan(struct bridge_id_entry_item *br_item,
 	u32 idx, inst;
 	int vap;
 
-	/*br_info = dp_swdev_bridge_entry_lookup(br_item->br_device_name,
-	 *br_item->inst);
-	 *if (!br_info)
-	 *	return 0;
-	 */
 	/*if (br_info->flag & LOGIC_DEV_REGISTER) {*/
 	if (br_item->flags & LOGIC_DEV_REGISTER) {
 		/*get_vlan_via_dev(dev, &vlan_prop);*/
@@ -315,12 +323,13 @@ static int dp_swdev_filter_vlan(struct net_device *dev,
 		/* current bridge member port*/
 		br_item->portid = subif.bport;
 		swdev_lock();
-		br_info = dp_swdev_bridge_entry_lookup(br_dev->name,
-						       subif.inst);
+		br_info = dp_swdev_bridge_entry_lookup(br_dev->name);
 		if (br_info) {
 			strcpy(br_item->br_device_name,
 			       br_info->br_device_name);
 			br_item->fid = br_info->fid;
+		} else {
+			return -EOPNOTSUPP;
 		}
 		switchdev_trans_item_enqueue(trans, br_item,
 					     kfree, &br_item->tritem);
@@ -383,8 +392,7 @@ static int dp_swdev_cfg_gswip(struct bridge_id_entry_item *br_item, u8 *addr)
 			return 0;
 		}
 	} else {
-		br_info = dp_swdev_bridge_entry_lookup(br_item->br_device_name,
-						       br_item->inst);
+		br_info = dp_swdev_bridge_entry_lookup(br_item->br_device_name);
 		if (!br_info)
 			return 0;
 		br_info->flag = 0;
@@ -469,8 +477,7 @@ static int dp_swdev_add_if(struct net_device *dev,
 		/* current bridge member port*/
 		br_item->portid = subif.bport;
 		swdev_lock();
-		br_info = dp_swdev_bridge_entry_lookup(br_dev->name,
-						       subif.inst);
+		br_info = dp_swdev_bridge_entry_lookup(br_dev->name);
 		if (br_info) {
 			strcpy(br_item->br_device_name,
 			       br_info->br_device_name);
@@ -519,23 +526,12 @@ static int dp_swdev_del_if(struct net_device *dev,
 {
 	struct br_info *br_info;
 	struct bridge_id_entry_item *br_item;
-	struct net_device *base, *master_dev;
+	struct net_device *base;
 	struct bridge_member_port *temp_list = NULL;
 	dp_subif_t subif = {0};
 	int port, inst;
-	bool f_unlock = false;
 	u8 *addr = (u8 *)dev->dev_addr;
 
-	if (!rtnl_is_locked()) {
-		rtnl_lock();
-		f_unlock = true;
-	}
-	master_dev = netdev_master_upper_dev_get(attr->orig_dev);
-	if (f_unlock)
-		rtnl_unlock();
-
-	DP_DEBUG(DP_DBG_FLAG_SWDEV, "%s MASTER DEV %s\n", __func__,
-		 master_dev ? master_dev->name : "NULL");
 	/* SWITCHDEV_TRANS_PREPARE phase */
 	if (switchdev_trans_ph_prepare(trans)) {
 		/*Get current BR_PORT ID from DP*/
@@ -551,8 +547,7 @@ static int dp_swdev_del_if(struct net_device *dev,
 			/*TODO need to check dequeue if no memory*/
 			return -ENOMEM;
 		swdev_lock();
-		br_info = dp_swdev_bridge_entry_lookup(br_dev->name,
-						       subif.inst);
+		br_info = dp_swdev_bridge_entry_lookup(br_dev->name);
 		if (br_info) {
 			br_item->fid = br_info->fid;
 			br_item->inst = subif.inst;
@@ -639,14 +634,13 @@ int dp_del_br_if(struct net_device *dev, struct net_device *br_dev,
 	struct br_info *br_info;
 	struct bridge_id_entry_item *br_item;
 	struct bridge_member_port *temp_list = NULL;
-	dp_subif_t subif = {0};
 	u8 *addr = (u8 *)dev->dev_addr;
 
 	br_item = kmalloc(sizeof(*br_item), GFP_KERNEL);
 	if (!br_item)
 		return -1;
 	swdev_lock();
-	br_info = dp_swdev_bridge_entry_lookup(br_dev->name, subif.inst);
+	br_info = dp_swdev_bridge_entry_lookup(br_dev->name);
 	if (br_info) {
 		br_item->fid = br_info->fid;
 		br_item->inst = inst;
@@ -681,7 +675,6 @@ static int dp_swdev_port_attr_set(struct net_device *dev,
 {
 	int err = -EOPNOTSUPP;
 	struct net_device *br_dev;
-	bool f_unlock = false;
 #ifdef CONFIG_LTQ_DATAPATH_SWDEV_TEST
 	{
 		struct net_device *br_dev =
@@ -708,13 +701,7 @@ static int dp_swdev_port_attr_set(struct net_device *dev,
 	/* switchdev attr orig dev -> bridge port dev pointer
 	 *then get the bridge dev from switchdev attr's orig dev
 	 */
-	if (!rtnl_is_locked()) {
-		rtnl_lock();
-		f_unlock = true;
-	}
 	br_dev = netdev_master_upper_dev_get(attr->orig_dev);
-	if (f_unlock)
-		rtnl_unlock();
 	if (!br_dev)
 		return -EOPNOTSUPP;
 #if 1
@@ -765,18 +752,11 @@ static int dp_swdev_port_attr_get(struct net_device *dev,
 	struct net_device *br_dev;
 	struct br_info *br_info;
 	dp_subif_t subif = {0};
-	bool f_unlock = false;
 	/*For this api default err return value "-EOPNOTSUPP"
 	 * cannot be set as this blocks bridgeport offload_fwd_mark
 	 * setting at linux bridge level("nbp_switchdev_mark_set")
 	 */
-	if (!rtnl_is_locked()) {
-		rtnl_lock();
-		f_unlock = true;
-	}
 	br_dev = netdev_master_upper_dev_get(attr->orig_dev);
-	if (f_unlock)
-		rtnl_unlock();
 	if (!br_dev)
 		return 0;
 
@@ -789,8 +769,7 @@ static int dp_swdev_port_attr_get(struct net_device *dev,
 
 	switch (attr->id) {
 	case SWITCHDEV_ATTR_ID_PORT_PARENT_ID:
-		br_info = dp_swdev_bridge_entry_lookup(br_dev->name,
-						       subif.inst);
+		br_info = dp_swdev_bridge_entry_lookup(br_dev->name);
 		if (!br_info)
 			return 0;
 		if (br_info->fid < 0)
@@ -817,7 +796,6 @@ static int dp_swdev_port_obj_add(struct net_device *dev,
 {
 	int err = -EOPNOTSUPP;
 	struct net_device *br_dev;
-	bool f_unlock = false;
 #ifdef CONFIG_LTQ_DATAPATH_SWDEV_TEST
 	{
 		struct net_device *br_dev = netdev_master_upper_dev_get(dev);
@@ -845,18 +823,12 @@ static int dp_swdev_port_obj_add(struct net_device *dev,
 	DP_DEBUG(DP_DBG_FLAG_SWDEV, "%s id:%d flags:%d dev name:%s\r\n",
 		 __func__, obj->id,
 		 obj->flags, dev->name);
-	if (!rtnl_is_locked()) {
-		rtnl_lock();
-		f_unlock = true;
-	}
 	br_dev = netdev_master_upper_dev_get(obj->orig_dev);
-	if (f_unlock)
-		rtnl_unlock();
 	if (!br_dev)
 		return err;
 	switch (obj->id) {
 	case SWITCHDEV_OBJ_ID_PORT_VLAN:
-		dp_swdev_filter_vlan(obj->orig_dev, obj, trans, br_dev);
+		err = dp_swdev_filter_vlan(obj->orig_dev, obj, trans, br_dev);
 		break;
 	case SWITCHDEV_OBJ_ID_PORT_FDB:
 		break;
diff --git a/drivers/net/ethernet/lantiq/datapath/datapath_swdev.h b/drivers/net/ethernet/lantiq/datapath/datapath_swdev.h
index f00399bac033..993233985948 100644
--- a/drivers/net/ethernet/lantiq/datapath/datapath_swdev.h
+++ b/drivers/net/ethernet/lantiq/datapath/datapath_swdev.h
@@ -61,7 +61,7 @@ extern struct hlist_head
 	g_bridge_id_entry_hash_table[DP_MAX_INST][BR_ID_ENTRY_HASH_TABLE_SIZE];
 int dp_swdev_bridge_id_entry_free(int instance);
 int dp_swdev_bridge_id_entry_init(void);
-struct br_info *dp_swdev_bridge_entry_lookup(char *br_name, int inst);
+struct br_info *dp_swdev_bridge_entry_lookup(char *br_name);
 int dp_swdev_chk_bport_in_br(struct net_device *bp_dev, int bport, int inst);
 u16 crc_cal(const u8 *data, u16 len);
 u16 dp_swdev_cal_hash(u8 *dev_name);
diff --git a/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_gswip.c b/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_gswip.c
index 9e2608d37e7a..fd25e7d06d23 100644
--- a/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_gswip.c
+++ b/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_gswip.c
@@ -14,11 +14,27 @@
 #include <net/datapath_api.h>
 #include "../datapath.h"
 #include "datapath_misc.h"
-
 #if IS_ENABLED(CONFIG_LTQ_DATAPATH_DDR_SIMULATE_GSWIP31)
 #include "datapath_gswip_simulate.h"
 #endif
 
+#define GSW_CORE_API(_handle, a, b) ({ \
+	typeof(_handle) (handle) = (_handle); \
+	gsw_core_api((dp_gsw_cb)(handle)->a, (handle), (b)); })
+
+#define BP_CFG(bp_cfg, _index, bflag, id) ({ \
+	typeof(_index) (index) = (_index); \
+	(bp_cfg)->bEgressSubMeteringEnable[(index)] = bflag; \
+	(bp_cfg)->nEgressTrafficSubMeterId[(index)] = id; })
+
+#define BR_CFG(br_cfg, _index, bflag, id) ({\
+	typeof(_index) (index) = (_index); \
+	(br_cfg)->bSubMeteringEnable[(index)] = bflag; \
+	(br_cfg)->nTrafficSubMeterId[(index)] = id; })
+
+#define METER_CIR(cir)  ((cir) / 1000)
+#define METER_PIR(pir)  ((pir) / 1000)
+
 struct ctp_assign {
 	u32 flag; /*Datapath Device Flag */
 	GSW_LogicalPortMode_t emode; /*mapped GSWIP CTP flag */
@@ -980,3 +996,455 @@ int dp_get_gsw_pmapper_31(int inst, int bport, int lport,
 	}
 	return 0;
 }
+
+int dp_meter_alloc_31(int inst, int *meterid, int flag)
+{
+	struct core_ops *gsw_handle;
+	GSW_QoS_meterCfg_t meter_cfg = {0};
+	GSW_return_t ret;
+
+	if (inst < 0) {
+		PR_ERR("inst invalid\n");
+		return -1;
+	}
+	if (!meterid) {
+		PR_ERR("meterid NULL\n");
+		return -1;
+	}
+	gsw_handle = dp_port_prop[inst].ops[GSWIP_L];
+	if (!gsw_handle) {
+		PR_ERR("gsw_handle NULL\n");
+		return -1;
+	}
+	if (flag == DP_F_DEREGISTER && *meterid >= 0) {
+		meter_cfg.nMeterId = *meterid;
+		ret = GSW_CORE_API(gsw_handle, gsw_qos_ops.QOS_MeterAlloc,
+				   &meter_cfg);
+		if (ret != GSW_statusOk) {
+			PR_ERR("Meter dealloc failed: %d\n", ret);
+			return -1;
+		}
+		return 0;
+	}
+	memset(&meter_cfg, 0, sizeof(meter_cfg));
+	ret = GSW_CORE_API(gsw_handle, gsw_qos_ops.QOS_MeterAlloc,
+			   &meter_cfg);
+	if ((ret != GSW_statusOk) || (meter_cfg.nMeterId < 0)) {
+		PR_ERR("Failed to get a meter alloc\n");
+		*meterid = -1;
+		return -1;
+	}
+	*meterid = meter_cfg.nMeterId;
+	return 0;
+}
+
+int dp_meter_add_31(struct net_device *dev,  struct dp_meter_cfg  *meter,
+		    int flag, struct dp_meter_subif *mtr_subif)
+{
+	struct core_ops *gsw_handle;
+	GSW_QoS_meterCfg_t meter_cfg;
+	GSW_BRIDGE_portConfig_t *bp_cfg = NULL;
+	GSW_PCE_rule_t *pce_rule = NULL;
+	GSW_CTP_portConfig_t *ctp_cfg = NULL;
+	GSW_BRIDGE_config_t *br_cfg = NULL;
+	GSW_return_t ret;
+	int bret = 0;
+
+	if(!mtr_subif) {
+		PR_ERR("mtr_subif NULL\n");
+		return -1;
+	}
+	gsw_handle = dp_port_prop[mtr_subif->inst].ops[GSWIP_L];
+	if (!gsw_handle)
+		return -1;
+
+	memset(&meter_cfg, 0, sizeof(GSW_QoS_meterCfg_t));
+	meter_cfg.nCbs = meter->cbs;
+	meter_cfg.nRate = METER_CIR(meter->cir);
+	meter_cfg.nEbs = meter->pbs;
+	meter_cfg.nPiRate = METER_PIR(meter->pir);
+	meter_cfg.bEnable = 1;
+	if (meter->type == srTCM) {
+		meter_cfg.eMtrType = GSW_QOS_Meter_srTCM;
+	} else if (meter->type == trTCM) {
+		meter_cfg.eMtrType = GSW_QOS_Meter_trTCM;
+	} else {
+		PR_ERR(" invalid meter type\n");
+		return -1;
+	}
+	meter_cfg.nMeterId = meter->meter_id;
+	if (flag & DP_METER_COL_MARKING_ONLY)
+		meter_cfg.nColourBlindMode = meter->mode;
+	ret = GSW_CORE_API(gsw_handle, gsw_qos_ops.QoS_MeterCfgSet,
+			   &meter_cfg);
+	if (ret != GSW_statusOk) {
+		PR_ERR("MeterCfgSet API failed:%d\n", ret);
+		return -1;
+	}
+
+	if (flag & DP_METER_ATTACH_PCE) {
+		/* pattern setting */
+		pce_rule = kzalloc(sizeof(GSW_PCE_rule_t), GFP_KERNEL);
+		if (!pce_rule) {
+			PR_ERR("ctp_cfg alloc failed\n");
+			bret = -1;
+			goto err;
+		}
+		pce_rule->pattern.nIndex = meter->dp_pce.pce_idx;
+		pce_rule->pattern.bEnable = 1;
+		/* action setting */
+		pce_rule->action.eMeterAction = GSW_PCE_ACTION_METER_1;
+		pce_rule->action.nMeterId =  meter->meter_id;
+		ret = GSW_CORE_API(gsw_handle, gsw_tflow_ops.TFLOW_PceRuleWrite,
+				   pce_rule);
+		if (ret != GSW_statusOk) {
+			PR_ERR("PceRule Write API failed :%d\n", ret);
+			goto err;
+		}
+	}
+	if (flag & DP_METER_ATTACH_CTP) {/* CTP port Flag */
+		struct pmac_port_info *port_info;
+
+		if (mtr_subif->subif.flag_pmapper) {
+			PR_ERR("can't use CTP,pmapper is enable\n");
+			bret = -1;
+			goto err;
+		}
+		ctp_cfg = kzalloc(sizeof(GSW_CTP_portConfig_t), GFP_KERNEL);
+		if (!ctp_cfg) {
+			PR_ERR("ctp_cfg alloc failed\n");
+			bret = -1;
+			goto err;
+		}
+		port_info =
+		&dp_port_info[mtr_subif->subif.inst][mtr_subif->subif.port_id];
+		if (!port_info) {
+			PR_ERR(" port_info is NULL\n");
+			bret = -1;
+			goto err;
+		}
+		ctp_cfg->nLogicalPortId = mtr_subif->subif.port_id;
+		ctp_cfg->nSubIfIdGroup  = GET_VAP(mtr_subif->subif.subif,
+						 port_info->vap_offset,
+						 port_info->vap_mask);
+		ret = GSW_CORE_API(gsw_handle, gsw_ctp_ops.CTP_PortConfigGet,
+				   ctp_cfg);
+		if (ret != GSW_statusOk) {
+			PR_ERR("PortConfigGet API failed :%d\n", ret);
+			bret = -1;
+			goto err;
+		}
+		if (meter->dir == DP_DIR_EGRESS) {
+			ctp_cfg->eMask = GSW_CTP_PORT_CONFIG_EGRESS_METER;
+			ctp_cfg->bEgressMeteringEnable = 1;
+			ctp_cfg->nEgressTrafficMeterId =  meter->meter_id;
+		} else if (meter->dir == DP_DIR_INGRESS) {
+			ctp_cfg->eMask = GSW_CTP_PORT_CONFIG_INGRESS_METER;
+			ctp_cfg->bIngressMeteringEnable = 1;
+			ctp_cfg->nIngressTrafficMeterId =  meter->meter_id;
+		} else {
+			PR_ERR(" invalid meter dir\n");
+			return -1;
+		}
+		ret = GSW_CORE_API(gsw_handle, gsw_ctp_ops.CTP_PortConfigSet,
+				   ctp_cfg);
+		if (ret != GSW_statusOk) {
+			PR_ERR("PortConfigSet API failed :%d\n", ret);
+			bret = -1;
+			goto err;
+		}
+	}
+	if (flag & DP_METER_ATTACH_BRPORT) {/*BRIDGE port Flag*/
+		if (!mtr_subif->subif.flag_bp) {
+			PR_ERR("flag_bp value 0\n");
+			bret = -1;
+			goto err;
+		}
+		bp_cfg = kzalloc(sizeof(GSW_BRIDGE_portConfig_t), GFP_KERNEL);
+		if (!bp_cfg) {
+			PR_ERR("bp_cfg alloc failed\n");
+			bret = -1;
+			goto err;
+		}
+		bp_cfg->nBridgePortId = mtr_subif->subif.bport;
+		ret = GSW_CORE_API(gsw_handle,
+				   gsw_brdgport_ops.BridgePort_ConfigGet,
+				   bp_cfg);
+		if (ret != GSW_statusOk) {
+			PR_ERR("BridgePort_ConfigGet API failed :%d\n", ret);
+			bret = -1;
+			goto err;
+		}
+		if (meter->dir == DP_DIR_EGRESS) {
+			bp_cfg->eMask =
+				GSW_BRIDGE_PORT_CONFIG_MASK_EGRESS_SUB_METER;
+			if (meter->dp_pce.flow == DP_UKNOWN_UNICAST)
+				BP_CFG(bp_cfg,
+				       GSW_BRIDGE_PORT_EGRESS_METER_UNKNOWN_UC,
+				       meter->meter_id, 1);
+			else if (meter->dp_pce.flow == DP_MULTICAST)
+				BP_CFG(bp_cfg,
+				       GSW_BRIDGE_PORT_EGRESS_METER_MULTICAST,
+				       meter->meter_id, 1);
+			else if (meter->dp_pce.flow == DP_BROADCAST)
+				BP_CFG(bp_cfg,
+				       GSW_BRIDGE_PORT_EGRESS_METER_BROADCAST,
+				       meter->meter_id, 1);
+			else
+				BP_CFG(bp_cfg,
+				       GSW_BRIDGE_PORT_EGRESS_METER_OTHERS,
+				       meter->meter_id, 1);
+		} else if (meter->dir == DP_DIR_INGRESS) {
+			bp_cfg->eMask =
+				GSW_BRIDGE_PORT_CONFIG_MASK_INGRESS_METER;
+			bp_cfg->bIngressMeteringEnable = 1;
+			bp_cfg->nIngressTrafficMeterId = meter->meter_id;
+		} else {
+			PR_ERR(" invalid meter dir\n");
+			return -1;
+		}
+		ret = GSW_CORE_API(gsw_handle,
+				   gsw_brdgport_ops.BridgePort_ConfigSet,
+				   bp_cfg);
+		if (ret != GSW_statusOk) {
+			PR_ERR("BridgePort_ConfigSet API failed :%d\n", ret);
+			bret = -1;
+			goto err;
+		}
+	} else if (flag & DP_METER_ATTACH_BRIDGE) {
+		br_cfg = kzalloc(sizeof(GSW_BRIDGE_config_t), GFP_KERNEL);
+		if (!br_cfg) {
+			PR_ERR("br_cfg alloc failed\n");
+			bret = -1;
+			goto err;
+		}
+		br_cfg->nBridgeId = mtr_subif->fid;
+		ret = GSW_CORE_API(gsw_handle,
+				   gsw_brdg_ops.Bridge_ConfigGet,
+				   br_cfg);
+		if (ret != GSW_statusOk) {
+			PR_ERR("Bridge_ConfigGet API failed :%d\n", ret);
+			bret = -1;
+			goto err;
+		}
+		br_cfg->eMask = GSW_BRIDGE_CONFIG_MASK_SUB_METER;
+		if (meter->dp_pce.flow == DP_UKNOWN_UNICAST)
+			BR_CFG(br_cfg,
+			       GSW_BRIDGE_PORT_EGRESS_METER_UNKNOWN_UC,
+			       meter->meter_id, 1);
+		else if (meter->dp_pce.flow == DP_MULTICAST)
+			BR_CFG(br_cfg,
+			       GSW_BRIDGE_PORT_EGRESS_METER_MULTICAST,
+			       meter->meter_id, 1);
+		else if (meter->dp_pce.flow == DP_BROADCAST)
+			BR_CFG(br_cfg,
+			       GSW_BRIDGE_PORT_EGRESS_METER_BROADCAST,
+			       meter->meter_id, 1);
+		else {
+			PR_ERR("Meter flow invalid\n");
+			bret = -1;
+			goto err;
+		}
+		ret = GSW_CORE_API(gsw_handle, gsw_brdg_ops.Bridge_ConfigSet,
+				   br_cfg);
+		if (ret != GSW_statusOk) {
+			PR_ERR("Bridge_ConfigSet API failed :%d\n", ret);
+			bret = -1;
+			goto err;
+		}
+	}
+err:
+	kfree(br_cfg);
+	kfree(bp_cfg);
+	kfree(ctp_cfg);
+	kfree(pce_rule);
+	return bret;
+}
+
+int dp_meter_del_31(struct net_device *dev,  struct dp_meter_cfg  *meter,
+		    int flag, struct dp_meter_subif *mtr_subif)
+{
+	struct core_ops *gsw_handle;
+	GSW_BRIDGE_portConfig_t *bp_cfg = NULL;
+	GSW_PCE_rule_t *pce_rule = NULL;
+	GSW_CTP_portConfig_t *ctp_cfg = NULL;
+	GSW_BRIDGE_config_t *br_cfg = NULL;
+	GSW_return_t ret;
+	int bret = 0;
+
+	if (!mtr_subif) {
+		PR_ERR(" mtr_subif NULL\n");
+		return -1;
+	}
+	gsw_handle = dp_port_prop[mtr_subif->inst].ops[GSWIP_L];
+	if (!gsw_handle)
+		return -1;
+
+	if (meter->dir & DP_METER_ATTACH_PCE) {
+		pce_rule = kzalloc(sizeof(GSW_PCE_rule_t), GFP_KERNEL);
+		if (!pce_rule) {
+			PR_ERR("ctp_cfg alloc failed\n");
+			bret = -1;
+			goto err;
+		}
+		/* pattern setting */
+		pce_rule->pattern.nIndex = meter->dp_pce.pce_idx;
+		pce_rule->pattern.bEnable = 0;
+		ret = GSW_CORE_API(gsw_handle, gsw_tflow_ops.TFLOW_PceRuleWrite,
+				   pce_rule);
+		if (ret != GSW_statusOk) {
+			PR_ERR("PceRule Write API failed :%d\n", ret);
+			bret = -1;
+			goto err;
+		}
+	}
+	if (flag & DP_METER_ATTACH_CTP) {
+		struct pmac_port_info *port_info;
+
+		if (mtr_subif->subif.flag_pmapper) {
+			PR_ERR("flag_pmapper is set\n");
+			bret = -1;
+			goto err;
+		}
+		ctp_cfg = kzalloc(sizeof(GSW_CTP_portConfig_t), GFP_KERNEL);
+		if (!ctp_cfg) {
+			PR_ERR("ctp_cfg alloc failed\n");
+			bret = -1;
+			goto err;
+		}
+		port_info = &dp_port_info[mtr_subif->subif.inst][mtr_subif->subif.port_id];
+		if (!port_info) {
+			PR_ERR(" port_info is NULL\n");
+			bret = -1;
+			goto err;
+		}
+		ctp_cfg->nLogicalPortId = mtr_subif->subif.port_id;
+		ctp_cfg->nSubIfIdGroup = GET_VAP(mtr_subif->subif.subif,
+							port_info->vap_offset,
+							port_info->vap_mask);
+		if (meter->dir == DP_DIR_EGRESS)
+			ctp_cfg->nEgressTrafficMeterId =  meter->meter_id;
+		else if (meter->dir == DP_DIR_INGRESS)
+			ctp_cfg->nIngressTrafficMeterId =  meter->meter_id;
+		ret = GSW_CORE_API(gsw_handle, gsw_ctp_ops.CTP_PortConfigGet,
+				   ctp_cfg);
+		if (ret != GSW_statusOk) {
+			bret = -1;
+			goto err;
+		}
+		if (meter->dir == DP_DIR_EGRESS) {
+			ctp_cfg->eMask = GSW_CTP_PORT_CONFIG_EGRESS_METER;
+			ctp_cfg->bEgressMeteringEnable = 0;
+		} else if (meter->dir == DP_DIR_INGRESS) {
+			ctp_cfg->eMask = GSW_CTP_PORT_CONFIG_INGRESS_METER;
+			ctp_cfg->bIngressMeteringEnable = 0;
+		}
+		ret = GSW_CORE_API(gsw_handle, gsw_ctp_ops.CTP_PortConfigSet,
+				   ctp_cfg);
+		if (ret != GSW_statusOk) {
+			bret = -1;
+			goto err;
+		}
+	}
+	if (flag & DP_METER_ATTACH_BRPORT) {
+		if (!mtr_subif->subif.flag_bp) {
+			PR_ERR("flag_bp is 0\n");
+			bret = -1;
+			goto err;
+		}
+		bp_cfg = kzalloc(sizeof(GSW_BRIDGE_portConfig_t), GFP_KERNEL);
+		if (!bp_cfg) {
+			PR_ERR("bp_cfg alloc failed\n");
+			bret = -1;
+			goto err;
+		}
+		bp_cfg->nBridgePortId = mtr_subif->subif.bport;
+		ret = GSW_CORE_API(gsw_handle,
+				   gsw_brdgport_ops.BridgePort_ConfigGet,
+				   bp_cfg);
+		if (ret != GSW_statusOk) {
+			PR_ERR("BridgePort_ConfigGet API failed\n");
+			bret = -1;
+			goto err;
+		}
+		if (meter->dir == DP_DIR_EGRESS) {
+			bp_cfg->eMask =
+				GSW_BRIDGE_PORT_CONFIG_MASK_EGRESS_SUB_METER;
+			if (meter->dp_pce.flow == DP_UKNOWN_UNICAST)
+				BP_CFG(bp_cfg,
+				       GSW_BRIDGE_PORT_EGRESS_METER_UNKNOWN_UC,
+				       meter->meter_id, 0);
+			else if (meter->dp_pce.flow == DP_MULTICAST)
+				BP_CFG(bp_cfg,
+				       GSW_BRIDGE_PORT_EGRESS_METER_MULTICAST,
+				       meter->meter_id, 0);
+			else if (meter->dp_pce.flow == DP_BROADCAST)
+				BP_CFG(bp_cfg,
+				       GSW_BRIDGE_PORT_EGRESS_METER_BROADCAST,
+				       meter->meter_id, 0);
+			else
+				BP_CFG(bp_cfg,
+				       GSW_BRIDGE_PORT_EGRESS_METER_OTHERS,
+				       meter->meter_id, 0);
+		} else {
+			bp_cfg->eMask =
+				GSW_BRIDGE_PORT_CONFIG_MASK_INGRESS_METER;
+			bp_cfg->bIngressMeteringEnable = 0;
+		}
+		ret = GSW_CORE_API(gsw_handle,
+				   gsw_brdgport_ops.BridgePort_ConfigSet,
+				   bp_cfg);
+		if (ret != GSW_statusOk) {
+			PR_ERR("BridgePort_ConfigSet API failed\n");
+			bret = -1;
+			goto err;
+		}
+	}
+	if (flag & DP_METER_ATTACH_BRIDGE) {
+		br_cfg = kzalloc(sizeof(GSW_BRIDGE_config_t), GFP_KERNEL);
+		if (!br_cfg) {
+			PR_ERR("br_cfg alloc failed\n");
+			bret = -1;
+			goto err;
+		}
+		br_cfg->nBridgeId = mtr_subif->fid;
+		ret = GSW_CORE_API(gsw_handle, gsw_brdg_ops.Bridge_ConfigGet,
+				   br_cfg);
+		if (ret != GSW_statusOk) {
+			PR_ERR("Bridge_ConfigGet API failed :%d\n", ret);
+			bret = -1;
+			goto err;
+		}
+		br_cfg->eMask = GSW_BRIDGE_CONFIG_MASK_SUB_METER;
+		if (meter->dp_pce.flow == DP_UKNOWN_UNICAST)
+			BR_CFG(br_cfg,
+			       GSW_BRIDGE_PORT_EGRESS_METER_UNKNOWN_UC,
+			       meter->meter_id, 0);
+		else if (meter->dp_pce.flow == DP_MULTICAST)
+			BR_CFG(br_cfg,
+			       GSW_BRIDGE_PORT_EGRESS_METER_MULTICAST,
+			       meter->meter_id, 0);
+		else if (meter->dp_pce.flow == DP_BROADCAST)
+			BR_CFG(br_cfg,
+			       GSW_BRIDGE_PORT_EGRESS_METER_BROADCAST,
+			       meter->meter_id, 0);
+		else {
+			PR_ERR("Meter flow invalid\n");
+			bret = -1;
+			goto err;
+		}
+		ret = GSW_CORE_API(gsw_handle, gsw_brdg_ops.Bridge_ConfigSet,
+				   br_cfg);
+		if (ret != GSW_statusOk) {
+			PR_ERR("Bridge_ConfigSet API failed :%d\n", ret);
+			bret = -1;
+			goto err;
+		}
+	}
+err:
+	kfree(br_cfg);
+	kfree(bp_cfg);
+	kfree(ctp_cfg);
+	kfree(pce_rule);
+	return bret;
+}
diff --git a/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_misc.c b/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_misc.c
index 13c6134f4805..5a77e819fa92 100644
--- a/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_misc.c
+++ b/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_misc.c
@@ -36,6 +36,7 @@
 #include <net/datapath_api.h>
 #include <net/datapath_api_gswip31.h>
 #include "../datapath.h"
+#include "../datapath_instance.h"
 #include "datapath_proc.h"
 #include "datapath_ppv4.h"
 #include "datapath_misc.h"
@@ -1324,6 +1325,51 @@ static int subif_platform_set_unexplicit(int inst, int port_id,
 	return 0;
 }
 
+static int dp_ctp_tc_map_set_31(struct dp_tc_cfg *tc, int flag,
+				struct dp_meter_subif *mtr_subif)
+{
+	struct core_ops *gsw_handle;
+	GSW_CTP_portConfig_t ctp_tc_cfg;
+
+	memset(&ctp_tc_cfg, 0, sizeof(ctp_tc_cfg));
+
+	if (!mtr_subif) {
+		PR_ERR("mtr_subif struct NULL\n");
+		return -1;
+	}
+	if (mtr_subif->subif.flag_pmapper) {
+		PR_ERR("Cannot support ctp tc set for pmmapper dev(%s)\n",
+		       tc->dev ? tc->dev->name : "NULL");
+		return -1;
+	}
+	gsw_handle = dp_port_prop[mtr_subif->inst].ops[GSWIP_L];
+	ctp_tc_cfg.nLogicalPortId = mtr_subif->subif.port_id;
+	ctp_tc_cfg.nSubIfIdGroup = mtr_subif->subif.subif;
+		PR_ERR("Failed to get CTP info for ep=%d subif=%d\n",
+		       mtr_subif->subif.port_id, mtr_subif->subif.subif);
+	if (gsw_core_api((dp_gsw_cb)gsw_handle->gsw_ctp_ops.CTP_PortConfigGet,
+			 gsw_handle, &ctp_tc_cfg) != 0) {
+		PR_ERR("Failed to get CTP info for ep=%d subif=%d\n",
+		       mtr_subif->subif.port_id, mtr_subif->subif.subif);
+		return -1;
+	}
+	ctp_tc_cfg.eMask = GSW_CTP_PORT_CONFIG_MASK_FORCE_TRAFFIC_CLASS;
+	ctp_tc_cfg.nDefaultTrafficClass = tc->tc;
+	if (tc->force)
+		ctp_tc_cfg.bForcedTrafficClass = tc->force;
+	else
+		ctp_tc_cfg.bForcedTrafficClass = 0;
+
+	if (gsw_core_api((dp_gsw_cb)gsw_handle->gsw_ctp_ops.CTP_PortConfigSet,
+			 gsw_handle, &ctp_tc_cfg) != 0) {
+		PR_ERR("CTP tc set fail for ep=%d subif=%d tc=%d force=%d\n",
+		       mtr_subif->subif.port_id, mtr_subif->subif.subif,
+		       tc->tc, tc->force);
+		return -1;
+	}
+	return 0;
+}
+
 static int not_valid_rx_ep(int ep)
 {
 	return (((ep >= 3) && (ep <= 6)) || (ep == 2) || (ep > 15));
@@ -1421,6 +1467,10 @@ int register_dp_cap_gswip31(int flag)
 	cap.info.dp_qos_platform_set = qos_platform_set;
 	cap.info.dp_set_gsw_pmapper = dp_set_gsw_pmapper_31;
 	cap.info.dp_get_gsw_pmapper = dp_get_gsw_pmapper_31;
+	cap.info.dp_ctp_tc_map_set = dp_ctp_tc_map_set_31;
+	cap.info.dp_meter_alloc = dp_meter_alloc_31;
+	cap.info.dp_meter_add = dp_meter_add_31;
+	cap.info.dp_meter_del = dp_meter_del_31;
 #ifdef CONFIG_LTQ_DATAPATH_HAL_GSWIP31_MIB
 	cap.info.dp_get_port_vap_mib = dp_get_port_vap_mib_31;
 	cap.info.dp_clear_netif_mib = dp_clear_netif_mib_31;
diff --git a/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_misc.h b/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_misc.h
index d59d80a167ee..211e63ef5084 100644
--- a/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_misc.h
+++ b/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_misc.h
@@ -164,6 +164,13 @@ int dp_children_get_31(struct dp_node_child *cfg, int flag);
 int dp_free_children_via_parent_31(struct dp_node_alloc *node, int flag);
 int dp_node_reserve(int inst, int ep, struct dp_port_data *data, int flags);
 int dp_qos_level_get_31(struct dp_qos_level *dp, int flag);
+int dp_meter_alloc_31(int inst, int *meterid, int flag);
+int dp_meter_add_31(struct net_device *dev,
+		    struct dp_meter_cfg *meter,
+		    int flag, struct dp_meter_subif *mtr_subif);
+int dp_meter_del_31(struct net_device *dev,
+		    struct dp_meter_cfg *meter,
+		    int flag, struct dp_meter_subif *mtr_subif);
 
 #if IS_ENABLED(CONFIG_LTQ_DATAPATH_DDR_SIMULATE_GSWIP31)
 GSW_return_t gsw_core_api_ddr_simu31(dp_gsw_cb func, void *ops, void *param);
diff --git a/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_proc.c b/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_proc.c
index 5a95f029d164..57c48ef2e85e 100644
--- a/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_proc.c
+++ b/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_proc.c
@@ -2074,8 +2074,7 @@ static ssize_t proc_swdev_brctl_write(struct file *file,
 	buf1[0] = 0;
 
 	if (dp_strncmpi(param_list[0], "brctl", strlen("brctl")) == 0) {
-		br_info = dp_swdev_bridge_entry_lookup(param_list[1],
-						       0);
+		br_info = dp_swdev_bridge_entry_lookup(param_list[1]);
 		if (br_info) {
 			print_bridge(br_info->fid, br_info->inst);
 			list_for_each_entry(temp_list,  &br_info->bp_list,
@@ -2301,6 +2300,9 @@ static ssize_t ep_port_write(struct file *file, const char *buf, size_t count,
 	char *param_list[10];
 	dp_pmac_cfg_t pmac_cfg;
 	int inst = 0;
+	int flag1 = 0;
+	struct dp_tc_cfg *tc;
+	struct dp_meter_subif mtr_subif = {0};
 
 	memset(&pmac_cfg, 0, sizeof(dp_pmac_cfg_t));
 	len = (sizeof(str) > count) ? count : sizeof(str) - 1;
@@ -2346,6 +2348,38 @@ static ssize_t ep_port_write(struct file *file, const char *buf, size_t count,
 			PR_INFO("pmac set configuration failed\n");
 			return -1;
 		}
+	} else if (dp_strncmpi(param_list[0], "ctp_tc",
+		   strlen("ctp_tc")) == 0) {
+		tc = kzalloc(sizeof(*tc), GFP_KERNEL);
+		if (!tc) {
+			PR_ERR("failed to alloc ctp tc %d bytes\n",
+			       sizeof(*tc));
+			return 0;
+		}
+		tc->dev = dev_get_by_name(&init_net, param_list[1]);
+		tc->tc = dp_atoi(param_list[2]);
+		flag1 = dp_atoi(param_list[3]);
+		if (tc->tc > 15) {
+			PR_ERR("traffic class value range 0-15 only\n");
+			kfree(tc);
+			return count;
+		}
+		tc->force = 0;
+		if (dp_get_netif_subifid(tc->dev, NULL, NULL, NULL,
+					 &mtr_subif.subif, 0)) {
+			DP_DEBUG(DP_DBG_FLAG_DBG, "get subifid fail(%s)\n",
+				 tc->dev ? tc->dev->name : "NULL");
+			kfree(tc);
+			return count;
+		}
+		mtr_subif.inst =  mtr_subif.subif.inst;
+		if (dp_port_prop[mtr_subif.inst].info.
+				dp_ctp_tc_map_set(tc, flag1,
+						  &mtr_subif))
+			PR_ERR("ctp_tc_set fail\n");
+		else
+			PR_INFO("ctp_tc_set success\n");
+		kfree(tc);
 	} else {
 		PR_INFO("wrong command\n");
 		goto help;
@@ -2366,6 +2400,7 @@ static ssize_t ep_port_write(struct file *file, const char *buf, size_t count,
 		"egress [ep_port]",
 		"['rx_dmachan/fcs/pmac/res_dw1/res1_dw0/res2_dw0] [value]");
 	PR_INFO("echo egress [ep_port] ['rm_l2hdr'] [value] > /proc/dp/ep\n");
+	PR_INFO("echo ctp_tc [dev] [val] [flag] > /proc/dp/ep\n");
 	return count;
 }
 
diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_defconf.c b/drivers/net/ethernet/lantiq/switch-api/gsw_defconf.c
index 259a8c1624a1..e0edd87db18f 100644
--- a/drivers/net/ethernet/lantiq/switch-api/gsw_defconf.c
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_defconf.c
@@ -552,7 +552,7 @@ static int pmac_glbl_cfg(struct core_ops *ops, u8 pmacid)
 	glbl_cfg.eShortFrmChkType = GSW_PMAC_SHORT_LEN_ENA_UNTAG;
 	glbl_cfg.bLongFrmChkDis = 1;
 	glbl_cfg.bProcFlagsEgCfgEna = 1;
-	glbl_cfg.eProcFlagsEgCfg = GSW_PMAC_PROC_FLAGS_FLAG;
+	glbl_cfg.eProcFlagsEgCfg = GSW_PMAC_PROC_FLAGS_MIX;
 
 	ops->gsw_pmac_ops.Pmac_Gbl_CfgSet(ops, &glbl_cfg);
 
diff --git a/include/net/datapath_api.h b/include/net/datapath_api.h
index c80397a747a2..cd23cb631dd8 100644
--- a/include/net/datapath_api.h
+++ b/include/net/datapath_api.h
@@ -289,6 +289,9 @@ typedef struct dp_subif {
 			  *   in case need call API dp_vlan_set to apply VLAN
 			  *   rule to CTP or bridge port
 			  */
+	u32 flag_pmapper : 1; /*!< output: flag to indicate whether this
+			       *   device is pmapper device
+			       */
 } dp_subif_t;
 
 typedef dp_subif_t PPA_SUBIF; /*!< @brief structure type dp_subif PPA_SUBIF*/
@@ -1260,5 +1263,13 @@ int dp_free_buffer(int inst, struct dp_buffer *buffer, u32 flag);
  */
 int dp_dma_chan_irq_rx_enable(int inst, struct dp_dma_ch *ch, int flag);
 
+/*!
+ *@brief Datapath Swdev API to get FID from bridge name
+ *@param[in] dev: network device pointer
+ *@param[out] inst: DP instance ID
+ *@return Returns GSWIP bridge id i.e. FID
+ */
+int dp_get_fid_by_brname(struct net_device *dev, int *inst);
+
 #endif /*DATAPATH_API_H */
 
diff --git a/include/net/datapath_api_qos.h b/include/net/datapath_api_qos.h
index 65ffa2767c3d..dc241e59eba0 100644
--- a/include/net/datapath_api_qos.h
+++ b/include/net/datapath_api_qos.h
@@ -1161,11 +1161,11 @@ struct dp_meter_cfg {
 	 /*!< color marking mode */
 	enum dp_col_marking mode;
 	 /*!< traffic flow type for bridge/PCE rule mode only */
-	union {
+	union dp_pce{
 		enum dp_meter_traffic_type flow;
 		/*!< PCE table rule index */
 		u32 pce_idx;
-	};
+	}dp_pce;
 };
 
 /*!< API dp_meter_alloc: allocate a meter resource
@@ -1175,7 +1175,7 @@ struct dp_meter_cfg {
  *	   DP_F_DEREGISTER - free an already allocated meter
  *
  */
-int dp_meter_alloc(int *meterid, int flag);
+int dp_meter_alloc(int inst, int *meterid, int flag);
 
 /*!< API dp_meter_add: setup meter/color marking and apply it to CTP/BP/Bridge
  * accordingly
diff --git a/include/net/datapath_inst.h b/include/net/datapath_inst.h
index 5bd0975863d3..d2fe7c2311df 100644
--- a/include/net/datapath_inst.h
+++ b/include/net/datapath_inst.h
@@ -37,6 +37,12 @@ enum DP_HW_CAP_VER {
 	GSWIP31_VER
 };
 
+struct dp_meter_subif {
+	int fid;
+	int inst;
+	dp_subif_t subif;
+};
+
 struct dp_inst_info {
 	int inst; /*! for register, it will be filled by DP,
 		   *  for de-register, the caller fill the instance id
@@ -108,6 +114,16 @@ struct inst_info {
 				  struct dp_pmapper *mapper, u32 flag);
 	int (*dp_get_gsw_pmapper)(int inst, int bport, int lport,
 				  struct dp_pmapper *mapper, u32 flag);
+	int (*dp_ctp_tc_map_set)(struct dp_tc_cfg *tc, int flag,
+				 struct dp_meter_subif *mtr_subif);
+	int (*dp_meter_alloc)(int inst, int *meterid, int flag);
+	int (*dp_meter_add)(struct net_device *dev,
+			    struct dp_meter_cfg *meter, int flag,
+			    struct dp_meter_subif *mtr_subif);
+	int (*dp_meter_del)(struct net_device *dev,
+			    struct dp_meter_cfg *meter, int flag,
+			    struct dp_meter_subif *mtr_subif);
+
 #if IS_ENABLED(CONFIG_LTQ_DATAPATH_SWITCHDEV)
 	int swdev_flag;
 	int (*swdev_alloc_bridge_id)(int inst);
@@ -142,7 +158,7 @@ struct inst_property {
 	struct inst_info info;
 	/*driver should know which HW to configure, esp for PCIe case */
 	struct core_ops *ops[DP_MAX_GSW_HANDLE];
-	struct mac_ops *mac_ops[DP_MAX_MAC_HANDLE];	
+	struct mac_ops *mac_ops[DP_MAX_MAC_HANDLE];
 	int cbm_inst;
 	int qos_inst;
 	void *priv_hal; /*private data per HAL */
